/*  Generated by CHR bootstrap compiler
    From: chr_translate_bootstrap1.chr
    Date: Fri Feb 18 13:54:42 2005

    DO NOT EDIT.  EDIT THE CHR FILE INSTEAD
*/

:-module(chr_translate_bootstrap1, [chr_translate/2]).
:-use_module(chr_runtime).
:-style_check(-singleton).
:-style_check(- (discontiguous)).
:-use_module(library(lists)).
:-use_module(hprolog).
:-use_module(library(assoc)).
:-use_module(pairlist).
:-use_module(library(ordsets)).
:-include(chr_op2).
chr_translate(A, B) :-
	init_chr_pp_flags,
	partition_clauses(A, C, D, E),
	(   C==[]
	->  B=E
	;   check_rules(D, C),
	    unique_analyse_optimise(D, F),
	    check_attachments(F),
	    set_constraint_indices(C, 1),
	    store_management_preds(C, G),
	    constraints_code(C, F, H),
	    append_lists([E, G, H], B)
	),
	chr_clear.
store_management_preds(A, B) :-
	generate_attach_detach_a_constraint_all(A, C),
	generate_attach_increment(D),
	generate_attr_unify_hook(E),
	append_lists([C, D, E], B).
partition_clauses([], [], [], []).
partition_clauses([A|B], C, D, E) :-
	(   rule(A, F)
	->  C=G,
	    D=[F|H],
	    E=I
	;   is_declaration(A, J)
	->  append(J, G, C),
	    D=H,
	    E=I
	;   is_module_declaration(A, K)
	->  target_module(K),
	    C=G,
	    D=H,
	    E=[A|I]
	;   A=handler(L)
	->  format('CHR compiler WARNING: ~w.\n', [A]),
	    format('    `-->  SICStus compatibility: ignoring handler/1 declaration.\n', []),
	    C=G,
	    D=H,
	    E=I
	;   A=rules(M)
	->  format('CHR compiler WARNING: ~w.\n', [A]),
	    format('    `-->  SICStus compatibility: ignoring rules/1 declaration.\n', []),
	    C=G,
	    D=H,
	    E=I
	;   A=option(N, O)
	->  handle_option(N, O),
	    C=G,
	    D=H,
	    E=I
	;   C=G,
	    D=H,
	    E=[A|I]
	),
	partition_clauses(B, G, H, I).
is_declaration(A, B) :-
	(   A= (:-C)
	->  true
	;   A=C
	),
	C=..[constraints, D],
	conj2list(D, B).
rule(A, B) :-
	A= @(C, D), !,
	rule(D, yes(C), B).
rule(A, B) :-
	rule(A, no, B).
rule(A, B, C) :-
	A=pragma(D, E), !,
	is_rule(D, F, G),
	conj2list(E, H),
	C=pragma(F, G, H, B).
rule(A, B, C) :-
	is_rule(A, D, E),
	C=pragma(D, E, [], B).
is_rule(A, B, C) :-
	A= ==>(D, E), !,
	conj2list(D, F),
	get_ids(F, G, H),
	C=ids([], G),
	(   E= (I|J)
	->  B=rule([], H, I, J)
	;   B=rule([], H, true, E)
	).
is_rule(A, B, C) :-
	A= <=>(D, E), !,
	(   E= (F|G)
	->  H=F,
	    I=G
	;   H=true,
	    I=E
	),
	(   D= \(J, K)
	->  conj2list(J, L),
	    conj2list(K, M),
	    get_ids(L, N, O, 0, P),
	    get_ids(M, Q, R, P, S),
	    C=ids(Q, N)
	;   conj2list(D, M),
	    O=[],
	    get_ids(M, Q, R),
	    C=ids(Q, [])
	),
	B=rule(R, O, H, I).
get_ids(A, B, C) :-
	get_ids(A, B, C, 0, D).
get_ids([], [], [], A, A).
get_ids([A|B], [C|D], [E|F], C, G) :-
	(   A= #(E, C)
	->  true
	;   E=A
	),
	H is C+1,
	get_ids(B, D, F, H, G).
is_module_declaration((:-module(A)), A).
is_module_declaration((:-module(A, B)), A).
check_rules(A, B) :-
	check_rules(A, B, 1).
check_rules([], A, B).
check_rules([A|B], C, D) :-
	check_rule(A, C, D),
	E is D+1,
	check_rules(B, C, E).
check_rule(A, B, C) :-
	A=pragma(D, E, F, G),
	D=rule(H, I, J, K),
	append(H, I, L),
	check_head_constraints(L, B, A, C),
	check_pragmas(F, A, C).
check_head_constraints([], A, B, C).
check_head_constraints([A|B], C, D, E) :-
	functor(A, F, G),
	(   member(F/G, C)
	->  check_head_constraints(B, C, D, E)
	;   format('CHR compiler ERROR: Undeclared constraint ~w in head of ~@.\n', [F/G, format_rule(D, E)]),
	    format('    `--> Constraint should be on of ~w.\n', [C]),
	    fail
	).
check_pragmas([], A, B).
check_pragmas([A|B], C, D) :-
	check_pragma(A, C, D),
	check_pragmas(B, C, D).
check_pragma(A, B, C) :-
	var(A), !,
	format('CHR compiler ERROR: invalid pragma ~w in ~@.\n', [A, format_rule(B, C)]),
	format('    `--> Pragma should not be a variable!\n', []),
	fail.
check_pragma(passive(A), B, C) :- !,
	B=pragma(D, ids(E, F), G, H),
	(   memberchk_eq(A, E)
	->  true
	;   memberchk_eq(A, F)
	->  true
	;   format('CHR compiler ERROR: invalid identifier ~w in pragma passive in ~@.\n', [A, format_rule(B, C)]),
	    fail
	).
check_pragma(A, B, C) :-
	A=unique(D, E), !,
	format('CHR compiler WARNING: undocument pragma ~w in ~@.\n', [A, format_rule(B, C)]),
	format('    `--> Only use this pragma if you know what you are doing.\n', []).
check_pragma(A, B, C) :-
	A=already_in_heads, !,
	format('CHR compiler WARNING: currently unsupported pragma ~w in ~@.\n', [A, format_rule(B, C)]),
	format('    `--> Pragma is ignored. Termination and correctness may be affected \n', []).
check_pragma(A, B, C) :-
	A=already_in_head(D), !,
	format('CHR compiler WARNING: currently unsupported pragma ~w in ~@.\n', [A, format_rule(B, C)]),
	format('    `--> Pragma is ignored. Termination and correctness may be affected \n', []).
check_pragma(A, B, C) :-
	format('CHR compiler ERROR: invalid pragma ~w in ~@.\n', [A, format_rule(B, C)]),
	format('    `--> Pragma should be one of passive/1!\n', []),
	fail.
format_rule(A, B) :-
	A=pragma(C, D, E, F),
	(   F=yes(G)
	->  write('rule '),
	    write(G)
	;   write('rule number '),
	    write(B)
	).
handle_option(A, B) :-
	var(A), !,
	format('CHR compiler ERROR: ~w.\n', [option(A, B)]),
	format('    `--> First argument should be an atom, not a variable.\n', []),
	fail.
handle_option(A, B) :-
	var(B), !,
	format('CHR compiler ERROR: ~w.\n', [option(A, B)]),
	format('    `--> Second argument should be a nonvariable.\n', []),
	fail.
handle_option(A, B) :-
	option_definition(A, B, C), !,
	set_chr_pp_flags(C).
handle_option(A, B) :-
	\+option_definition(A, C, D), !.
handle_option(A, B) :-
	findall(C, option_definition(A, C, D), E),
	format('CHR compiler ERROR: ~w.\n', [option(A, B)]),
	format('    `--> Invalid value ~w: should be one of ~w.\n', [B, E]),
	fail.
option_definition(optimize, experimental, A) :-
	A=[unique_analyse_optimise-on, check_unnecessary_active-full, reorder_heads-on, set_semantics_rule-on, check_attachments-on, guard_via_reschedule-on].
option_definition(optimize, full, A) :-
	A=[unique_analyse_optimise-on, check_unnecessary_active-full, reorder_heads-on, set_semantics_rule-on, check_attachments-on, guard_via_reschedule-on].
option_definition(optimize, sicstus, A) :-
	A=[unique_analyse_optimise-off, check_unnecessary_active-simplification, reorder_heads-off, set_semantics_rule-off, check_attachments-off, guard_via_reschedule-off].
option_definition(optimize, off, A) :-
	A=[unique_analyse_optimise-off, check_unnecessary_active-off, reorder_heads-off, set_semantics_rule-off, check_attachments-off, guard_via_reschedule-off].
option_definition(debug, off, A) :-
	A=[debugable-off].
option_definition(debug, on, A) :-
	A=[debugable-on].
option_definition(check_guard_bindings, on, A) :-
	A=[guard_locks-on].
option_definition(check_guard_bindings, off, A) :-
	A=[guard_locks-off].
init_chr_pp_flags :-
	chr_pp_flag_definition(A, [B|C]),
	set_chr_pp_flag(A, B),
	fail.
init_chr_pp_flags.
set_chr_pp_flags([]).
set_chr_pp_flags([A-B|C]) :-
	set_chr_pp_flag(A, B),
	set_chr_pp_flags(C).
set_chr_pp_flag(A, B) :-
	atom_concat('$chr_pp_', A, C),
	nb_setval(C, B).
chr_pp_flag_definition(unique_analyse_optimise, [on, off]).
chr_pp_flag_definition(check_unnecessary_active, [full, simplification, off]).
chr_pp_flag_definition(reorder_heads, [on, off]).
chr_pp_flag_definition(set_semantics_rule, [on, off]).
chr_pp_flag_definition(guard_via_reschedule, [on, off]).
chr_pp_flag_definition(guard_locks, [on, off]).
chr_pp_flag_definition(check_attachments, [on, off]).
chr_pp_flag_definition(debugable, [off, on]).
chr_pp_flag(A, B) :-
	atom_concat('$chr_pp_', A, C),
	nb_getval(C, D),
	(   D==[]
	->  chr_pp_flag_definition(A, [B|E])
	;   D=B
	).
generate_attach_detach_a_constraint_all([], []).
generate_attach_detach_a_constraint_all([A|B], C) :-
	(   is_attached(A)
	->  generate_attach_a_constraint(A, D),
	    generate_detach_a_constraint(A, E)
	;   D=[],
	    E=[]
	),
	generate_attach_detach_a_constraint_all(B, F),
	append_lists([D, E, F], C).
generate_attach_a_constraint(A, [B, C]) :-
	generate_attach_a_constraint_empty_list(A, B),
	get_max_constraint_index(D),
	(   D==1
	->  generate_attach_a_constraint_1_1(A, C)
	;   generate_attach_a_constraint_t_p(A, C)
	).
generate_attach_a_constraint_empty_list(A/B, C) :-
	atom_concat_list([attach_, A, /, B], D),
	E=[[], F],
	G=..[D|E],
	C= (G:-true).
generate_attach_a_constraint_1_1(A/B, C) :-
	atom_concat_list([attach_, A, /, B], D),
	E=[[F|G], H],
	I=..[D|E],
	J=..[D, G, H],
	get_target_module(K),
	L= ((get_attr(F, K, M)->N=[H|M], put_attr(F, K, N);put_attr(F, K, [H])), J),
	C= (I:-L).
generate_attach_a_constraint_t_p(A/B, C) :-
	atom_concat_list([attach_, A, /, B], D),
	E=[[F|G], H],
	I=..[D|E],
	J=..[D, G, H],
	get_constraint_index(A/B, K),
	or_pattern(K, L),
	get_max_constraint_index(M),
	make_attr(M, N, O, P),
	nth(K, O, Q),
	substitute(Q, O, [H|Q], R),
	make_attr(M, N, R, S),
	substitute(Q, O, [H], T),
	make_attr(M, U, T, V),
	copy_term(O, W),
	nth(K, W, [H]),
	chr_delete(W, [H], X),
	set_elems(X, []),
	make_attr(M, L, W, Y),
	get_target_module(Z),
	A1= ((get_attr(F, Z, B1)->B1=P, (N/\L=:=L->put_attr(F, Z, S);U is N\/L, put_attr(F, Z, V));put_attr(F, Z, Y)), J),
	C= (I:-A1).
generate_detach_a_constraint(A, [B, C]) :-
	generate_detach_a_constraint_empty_list(A, B),
	get_max_constraint_index(D),
	(   D==1
	->  generate_detach_a_constraint_1_1(A, C)
	;   generate_detach_a_constraint_t_p(A, C)
	).
generate_detach_a_constraint_empty_list(A/B, C) :-
	atom_concat_list([detach_, A, /, B], D),
	E=[[], F],
	G=..[D|E],
	C= (G:-true).
generate_detach_a_constraint_1_1(A/B, C) :-
	atom_concat_list([detach_, A, /, B], D),
	E=[[F|G], H],
	I=..[D|E],
	J=..[D, G, H],
	get_target_module(K),
	L= ((get_attr(F, K, M)->'chr sbag_del_element'(M, H, N), (N==[]->del_attr(F, K);put_attr(F, K, N));true), J),
	C= (I:-L).
generate_detach_a_constraint_t_p(A/B, C) :-
	atom_concat_list([detach_, A, /, B], D),
	E=[[F|G], H],
	I=..[D|E],
	J=..[D, G, H],
	get_constraint_index(A/B, K),
	or_pattern(K, L),
	and_pattern(K, M),
	get_max_constraint_index(N),
	make_attr(N, O, P, Q),
	nth(K, P, R),
	substitute(R, P, [], S),
	make_attr(N, T, S, U),
	substitute(R, P, V, W),
	make_attr(N, O, W, X),
	get_target_module(Y),
	Z= ((get_attr(F, Y, A1)->A1=Q, (O/\L=:=L->'chr sbag_del_element'(R, H, V), (V==[]->T is O/\M, (T==0->del_attr(F, Y);put_attr(F, Y, U));put_attr(F, Y, X));true);true), J),
	C= (I:-Z).
generate_attach_increment([A, B]) :-
	generate_attach_increment_empty(A),
	get_max_constraint_index(C),
	(   C==1
	->  generate_attach_increment_one(B)
	;   generate_attach_increment_many(C, B)
	).
generate_attach_increment_empty((attach_increment([], A):-true)).
generate_attach_increment_one(A) :-
	B=attach_increment([C|D], E),
	get_target_module(F),
	G= ('chr not_locked'(C), (get_attr(C, F, H)->sort(H, I), merge(E, I, J), put_attr(C, F, J);put_attr(C, F, E)), attach_increment(D, E)),
	A= (B:-G).
generate_attach_increment_many(A, B) :-
	make_attr(A, C, D, E),
	make_attr(A, F, G, H),
	I=attach_increment([J|K], E),
	bagof(L, M^N^O^P^ (member2(D, G, M-N), L= (sort(N, O), 'chr merge_attributes'(M, O, P))), Q),
	list2conj(Q, R),
	bagof(S, T^U^V^member((T, 'chr merge_attributes'(U, V, S)), Q), W),
	make_attr(A, X, W, Y),
	get_target_module(Z),
	A1= ('chr not_locked'(J), (get_attr(J, Z, B1)->B1=H, R, X is C\/F, put_attr(J, Z, Y);put_attr(J, Z, E)), attach_increment(K, E)),
	B= (I:-A1).
generate_attr_unify_hook([A]) :-
	get_max_constraint_index(B),
	(   B==1
	->  generate_attr_unify_hook_one(A)
	;   generate_attr_unify_hook_many(B, A)
	).
generate_attr_unify_hook_one(A) :-
	B=C:attr_unify_hook(D, E),
	get_target_module(C),
	make_run_suspensions(F, G),
	make_run_suspensions(D, H),
	I= (sort(D, J), (var(E)-> (get_attr(E, C, K)->true;K=[]), sort(K, L), 'chr merge_attributes'(J, L, F), put_attr(E, C, F), G; (compound(E)->term_variables(E, M), attach_increment(M, J);true), H)),
	A= (B:-I).
generate_attr_unify_hook_many(A, B) :-
	make_attr(A, C, D, E),
	make_attr(A, F, G, H),
	bagof(I, J^K^ (member(J, D), I=sort(J, K)), L),
	list2conj(L, M),
	bagof(K, J^member(sort(J, K), L), N),
	bagof(O, P^Q^R^S^ (member2(N, G, P-Q), O= (sort(Q, R), 'chr merge_attributes'(P, R, S))), T),
	bagof(S, P^R^U^member((U, 'chr merge_attributes'(P, R, S)), T), V),
	list2conj(T, W),
	make_attr(A, X, V, Y),
	make_attr(A, C, N, Z),
	A1=B1:attr_unify_hook(E, C1),
	get_target_module(B1),
	make_run_suspensions_loop(V, D1),
	make_run_suspensions_loop(N, E1),
	F1= (M, (var(C1)-> (get_attr(C1, B1, G1)->G1=H, W, X is C\/F, put_attr(C1, B1, Y), D1;put_attr(C1, B1, Z), E1); (compound(C1)->term_variables(C1, H1), attach_increment(H1, Z);true), E1)),
	B= (A1:-F1).
make_run_suspensions(A, B) :-
	(   chr_pp_flag(debugable, on)
	->  B='chr run_suspensions_d'(A)
	;   B='chr run_suspensions'(A)
	).
make_run_suspensions_loop(A, B) :-
	(   chr_pp_flag(debugable, on)
	->  B='chr run_suspensions_loop_d'(A)
	;   B='chr run_suspensions_loop'(A)
	).
check_attachments(A) :-
	(   chr_pp_flag(check_attachments, on)
	->  check_attachments_(A)
	;   true
	).
check_attachments_([]).
check_attachments_([A|B]) :-
	check_attachment(A),
	check_attachments_(B).
check_attachment(A) :-
	A=pragma(B, C, D, E),
	B=rule(F, G, H, I),
	check_attachment_heads1(F, F, G, H),
	check_attachment_heads2(G, F, I).
check_attachment_heads1([], A, B, C).
check_attachment_heads1([A|B], C, D, E) :-
	functor(A, F, G),
	(   C==[A],
	    D==[],
	    E==true,
	    A=..[H|I],
	    no_matching(I, [])
	->  attached(F/G, no)
	;   attached(F/G, maybe)
	),
	check_attachment_heads1(B, C, D, E).
no_matching([], A).
no_matching([A|B], C) :-
	var(A),
	\+memberchk_eq(A, C),
	no_matching(B, [A|C]).
check_attachment_heads2([], A, B).
check_attachment_heads2([A|B], C, D) :-
	functor(A, E, F),
	(   C\==[],
	    D==true
	->  attached(E/F, maybe)
	;   attached(E/F, yes)
	),
	check_attachment_heads2(B, C, D).
all_attached([]).
all_attached([A|B]) :-
	functor(A, C, D),
	is_attached(C/D),
	all_attached(B).
set_constraint_indices([], A) :-
	B is A-1,
	max_constraint_index(B).
set_constraint_indices([A|B], C) :-
	(   is_attached(A)
	->  constraint_index(A, C),
	    D is C+1,
	    set_constraint_indices(B, D)
	;   set_constraint_indices(B, C)
	).
constraints_code(A, B, C) :-
	post_constraints(A, 1),
	constraints_code1(1, B, D, []),
	clean_clauses(D, C).
post_constraints([], A) :-
	B is A-1,
	constraint_count(B).
post_constraints([A/B|C], D) :-
	constraint(A/B, D),
	E is D+1,
	post_constraints(C, E).
constraints_code1(A, B, C, D) :-
	constraint_count(E),
	(   A>E
	->  D=C
	;   constraint_code(A, B, C, F),
	    G is A+1,
	    constraints_code1(G, B, F, D)
	).
constraint_code(A, B, C, D) :-
	constraint(E, A),
	constraint_prelude(E, F),
	C=[F|G],
	H=[0],
	rules_code(B, 1, A, H, I, G, J),
	gen_cond_attach_clause(E, I, J, D).
constraint_prelude(A/B, C) :-
	vars_susp(B, D, E, F),
	G=..[A|D],
	build_head(A, B, [0], F, H),
	get_target_module(I),
	(   chr_pp_flag(debugable, on)
	->  C= (G:-'chr allocate_constraint'(I:H, E, A, D), ('chr debug_event'(call(E)), H;'chr debug_event'(fail(E)), !, fail), ('chr debug_event'(exit(E));'chr debug_event'(redo(E)), fail))
	;   C= (G:-H)
	).
gen_cond_attach_clause(A/B, C, D, E) :-
	(   is_attached(A/B)
	->  (   C==[0]
	    ->  gen_cond_attach_goal(A/B, F, G, H, I)
	    ;   vars_susp(B, H, I, G),
		gen_uncond_attach_goal(A/B, I, F, J)
	    ),
	    (   chr_pp_flag(debugable, on)
	    ->  K=..[A|H],
		L='chr debug_event'(insert(#(K, I)))
	    ;   L=true
	    ),
	    build_head(A, B, C, G, M),
	    N= (M:-L, F),
	    D=[N|E]
	;   D=E
	).
gen_cond_attach_goal(A/B, C, D, E, F) :-
	vars_susp(B, E, F, D),
	build_head(A, B, [0], D, G),
	atom_concat_list([attach_, A, /, B], H),
	I=..[H, J, F],
	get_target_module(K),
	C= ((var(F)->'chr insert_constraint_internal'(J, F, K:G, A, E);'chr activate_constraint'(J, F, L)), I).
gen_uncond_attach_goal(A/B, C, D, E) :-
	atom_concat_list([attach_, A, /, B], F),
	G=..[F, H, C],
	D= ('chr activate_constraint'(H, C, E), G).
rules_code([], A, B, C, C, D, D).
rules_code([A|B], C, D, E, F, G, H) :-
	rule_code(A, C, D, E, I, G, J),
	K is C+1,
	rules_code(B, K, D, I, F, J, H).
rule_code(A, B, C, D, E, F, G) :-
	A=pragma(H, I, J, K),
	I=ids(L, M),
	H=rule(N, O, P, Q),
	heads1_code(N, [], L, [], A, C, D, F, R),
	heads2_code(O, [], M, [], A, B, C, D, E, R, G).
heads1_code([], A, B, C, D, E, F, G, G).
heads1_code([A|B], C, [D|E], F, G, H, I, J, K) :-
	G=pragma(L, M, N, O),
	constraint(P/Q, H),
	(   functor(A, P, Q),
	    \+check_unnecessary_active(A, C, L),
	    \+memberchk_eq(passive(D), N),
	    all_attached(B),
	    all_attached(C),
	    L=rule(R, S, T, U),
	    all_attached(S)
	->  append(B, C, V),
	    append(E, F, W),
	    head1_code(A, V, W, G, P/Q, H, I, J, X)
	;   J=X
	),
	heads1_code(B, [A|C], E, [D|F], G, H, I, X, K).
head1_code(A, B, C, D, E, F, G, H, I) :-
	D=pragma(J, K, L, M),
	J=rule(N, O, P, Q),
	(   O==[]
	->  reorder_heads(A, B, C, R, S),
	    simplification_code(A, R, S, D, E, G, H, I)
	;   simpagation_head1_code(A, B, C, D, E, G, H, I)
	).
heads2_code([], A, B, C, D, E, F, G, G, H, H).
heads2_code([A|B], C, [D|E], F, G, H, I, J, K, L, M) :-
	G=pragma(N, O, P, Q),
	constraint(R/S, I),
	(   functor(A, R, S),
	    \+check_unnecessary_active(A, C, N),
	    \+memberchk_eq(passive(D), P),
	    \+set_semantics_rule(G),
	    all_attached(B),
	    all_attached(C),
	    N=rule(T, U, V, W),
	    all_attached(T)
	->  append(B, C, X),
	    append(E, F, Y),
	    length(B, Z),
	    head2_code(A, X, Y, G, H, Z, R/S, J, L, A1),
	    inc_id(J, B1),
	    gen_alloc_inc_clause(R/S, J, A1, C1)
	;   L=C1,
	    B1=J
	),
	heads2_code(B, [A|C], E, [D|F], G, H, I, B1, K, C1, M).
head2_code(A, B, C, D, E, F, G, H, I, J) :-
	D=pragma(K, L, M, N),
	K=rule(O, P, Q, R),
	(   O==[]
	->  reorder_heads(A, B, S),
	    propagation_code(A, S, K, E, F, G, H, I, J)
	;   simpagation_head2_code(A, B, C, D, G, H, I, J)
	).
gen_alloc_inc_clause(A/B, C, D, E) :-
	vars_susp(B, F, G, H),
	build_head(A, B, C, H, I),
	inc_id(C, J),
	build_head(A, B, J, H, K),
	(   C==[0]
	->  gen_cond_allocation(F, G, A/B, H, L)
	;   L=true
	),
	M= (I:-L, K),
	D=[M|E].
gen_cond_allocation(A, B, C/D, E, F) :-
	build_head(C, D, [0], E, G),
	get_target_module(H),
	F= (var(B)->'chr allocate_constraint'(H:G, B, C, A);true).
guard_via_reschedule(A, B, C, D) :-
	(   chr_pp_flag(guard_via_reschedule, on)
	->  guard_via_reschedule_main(A, B, C, D)
	;   append(A, B, E),
	    list2conj(E, D)
	).
guard_via_reschedule_main(A, B, C, D) :-
	initialize_unit_dictionary(C, E),
	build_units(A, B, E, F),
	dependency_reorder(F, G),
	units2goal(G, D).
units2goal([], true).
units2goal([unit(A, B, C, D)|E], (B, F)) :-
	units2goal(E, F).
dependency_reorder(A, B) :-
	dependency_reorder(A, [], B).
dependency_reorder([], A, B) :-
	reverse(A, B).
dependency_reorder([A|B], C, D) :-
	A=unit(E, F, G, H),
	(   G==fixed
	->  I=[A|C]
	;   dependency_insert(C, A, H, I)
	),
	dependency_reorder(B, I, D).
dependency_insert([], A, B, [A]).
dependency_insert([A|B], C, D, E) :-
	A=unit(F, G, H, I),
	(   memberchk(F, D)
	->  E=[C, A|B]
	;   E=[A|J],
	    dependency_insert(B, C, D, J)
	).
build_units(A, B, C, D) :-
	build_retrieval_units(A, 1, E, C, F, D, G),
	build_guard_units(B, E, F, G).
build_retrieval_units([], A, A, B, B, C, C).
build_retrieval_units([A|B], C, D, E, F, G, H) :-
	term_variables(A, I),
	update_unit_dictionary(I, C, E, J, [], K),
	G=[unit(C, A, movable, K)|L],
	M is C+1,
	build_retrieval_units2(B, M, D, J, F, L, H).
build_retrieval_units2([], A, A, B, B, C, C).
build_retrieval_units2([A|B], C, D, E, F, G, H) :-
	term_variables(A, I),
	update_unit_dictionary(I, C, E, J, [], K),
	G=[unit(C, A, fixed, K)|L],
	M is C+1,
	build_retrieval_units(B, M, D, J, F, L, H).
initialize_unit_dictionary(A, B) :-
	term_variables(A, C),
	pair_all_with(C, 0, B).
update_unit_dictionary([], A, B, B, C, C).
update_unit_dictionary([A|B], C, D, E, F, G) :-
	(   lookup_eq(D, A, H)
	->  (   (   H==C
		;   memberchk(H, F)
		)
	    ->  I=F
	    ;   I=[H|F]
	    ),
	    J=D
	;   J=[A-C|D],
	    I=F
	),
	update_unit_dictionary(B, C, J, E, I, G).
build_guard_units(A, B, C, D) :-
	(   A=[E]
	->  D=[unit(B, E, fixed, [])]
	;   A=[E|F]
	->  term_variables(E, G),
	    update_unit_dictionary2(G, B, C, H, [], I),
	    D=[unit(B, E, movable, I)|J],
	    K is B+1,
	    build_guard_units(F, K, H, J)
	).
update_unit_dictionary2([], A, B, B, C, C).
update_unit_dictionary2([A|B], C, D, E, F, G) :-
	(   lookup_eq(D, A, H)
	->  (   (   H==C
		;   memberchk(H, F)
		)
	    ->  I=F
	    ;   I=[H|F]
	    ),
	    J=[A-C|D]
	;   J=[A-C|D],
	    I=F
	),
	update_unit_dictionary2(B, C, J, E, I, G).
unique_analyse_optimise(A, B) :-
	(   chr_pp_flag(unique_analyse_optimise, on)
	->  unique_analyse_optimise_main(A, 1, [], B)
	;   B=A
	).
unique_analyse_optimise_main([], A, B, []).
unique_analyse_optimise_main([A|B], C, D, [E|F]) :-
	(   discover_unique_pattern(A, C, G)
	->  H=[G|D]
	;   H=D
	),
	A=pragma(I, J, K, L),
	I=rule(M, N, O, P),
	J=ids(Q, R),
	apply_unique_patterns_to_constraints(M, Q, H, S),
	apply_unique_patterns_to_constraints(N, R, H, T),
	append_lists([S, T, K], U),
	E=pragma(I, J, U, L),
	V is C+1,
	unique_analyse_optimise_main(B, V, H, F).
apply_unique_patterns_to_constraints([], A, B, []).
apply_unique_patterns_to_constraints([A|B], [C|D], E, F) :-
	(   member(G, E),
	    apply_unique_pattern(A, C, G, H)
	->  F=[H|I]
	;   F=I
	),
	apply_unique_patterns_to_constraints(B, D, E, I).
apply_unique_pattern(A, B, C, D) :-
	C=unique(E, F),
	subsumes(A, E, G),
	(   setof(H, I^J^K^ (member(I, F), lookup_eq(G, I, J), term_variables(J, K), member(H, K)), L)
	->  true
	;   L=[]
	),
	D=unique(B, L).
subsumes(A, B, C) :-
	empty_assoc(D),
	subsumes_aux(A, B, D, E),
	assoc_to_list(E, F),
	build_unifier(F, C).
subsumes_aux(A, B, C, D) :-
	(   compound(B),
	    functor(B, E, F)
	->  compound(A),
	    functor(A, E, F),
	    subsumes_aux(F, A, B, C, D)
	;   A==B
	->  D=C
	;   var(B),
	    get_assoc(A, C, G)
	->  G==B,
	    D=C
	;   var(B),
	    put_assoc(A, C, B, D)
	).
subsumes_aux(0, A, B, C, C) :- !.
subsumes_aux(A, B, C, D, E) :-
	arg(A, B, F),
	arg(A, C, G),
	subsumes_aux(F, G, D, H),
	I is A-1,
	subsumes_aux(I, B, C, H, E).
build_unifier([], []).
build_unifier([A-B|C], [B-A|D]) :-
	build_unifier(C, D).
discover_unique_pattern(A, B, C) :-
	A=pragma(D, E, F, G),
	(   D=rule([H], [I], J, K)
	->  true
	;   D=rule([H, I], [], J, K)
	),
	check_unique_constraints(H, I, J, K, F, L),
	term_variables(H, M),
	select_pragma_unique_variables(L, M, N),
	O=unique(H, N),
	copy_term(O, C),
	(   prolog_flag(verbose, P),
	    P==yes
	->  format('Found unique pattern ~w in rule ~d~@\n', [C, B, (G=yes(Q)->write([58, 32]), write(Q);true)])
	;   true
	).
select_pragma_unique_variables([], A, []).
select_pragma_unique_variables([A-B|C], D, E) :-
	(   A==B
	->  E=[A|F]
	;   once((
		(   \+memberchk_eq(A, D)
		;   \+memberchk_eq(B, D)
		)
		)),
	    E=F
	),
	select_pragma_unique_variables(C, D, F).
check_unique_constraints(A, B, C, D, E, F) :-
	\+member(passive(G), E),
	variable_replacement(A-B, B-A, F),
	copy_with_variable_replacement(C, H, F),
	negate(C, I),
	once(entails(I, H)).
negate(true, fail).
negate(fail, true).
negate(A=<B, B<A).
negate(A>B, B>=A).
negate(A>=B, B>A).
negate(A<B, B=<A).
negate(var(A), nonvar(A)).
negate(nonvar(A), var(A)).
entails(A, B) :-
	B==A.
entails(fail, A).
entails(A>B, C>=D) :-
	C==A,
	D==B.
entails(A<B, C=<D) :-
	C==A,
	D==B.
entails(ground(A), nonvar(B)) :-
	B==A.
entails(compound(A), nonvar(B)) :-
	B==A.
entails(atomic(A), nonvar(B)) :-
	B==A.
entails(number(A), nonvar(B)) :-
	B==A.
entails(atom(A), nonvar(B)) :-
	B==A.
check_unnecessary_active(A, B, C) :-
	(   chr_pp_flag(check_unnecessary_active, full)
	->  check_unnecessary_active_main(A, B, C)
	;   chr_pp_flag(check_unnecessary_active, simplification),
	    C=rule(D, [], E, F)
	->  check_unnecessary_active_main(A, B, C)
	;   fail
	).
check_unnecessary_active_main(A, B, C) :-
	member(D, B),
	variable_replacement(D, A, E),
	copy_with_variable_replacement(C, F, E),
	identical_rules(C, F), !.
set_semantics_rule(A) :-
	(   chr_pp_flag(set_semantics_rule, on)
	->  set_semantics_rule_main(A)
	;   fail
	).
set_semantics_rule_main(A) :-
	A=pragma(B, C, D, E),
	B=rule([F], [G], true, H),
	C=ids([I], [J]),
	once(member(unique(I, K), D)),
	once(member(unique(J, L), D)),
	K==L,
	\+memberchk_eq(passive(I), D).
identical_rules(rule(A, B, C, D), rule(E, F, G, H)) :-
	C==G,
	identical_bodies(D, H),
	permutation(A, I),
	I==E,
	permutation(B, J),
	J==F.
identical_bodies(A, B) :-
	(   A= (C=D),
	    B= (E=F)
	->  (   C==E,
		D==F
	    ;   C==F,
		E==D
	    ), !
	;   A==B
	).
copy_with_variable_replacement(A, B, C) :-
	(   var(A)
	->  (   lookup_eq(C, A, B)
	    ->  true
	    ;   A=B
	    )
	;   functor(A, D, E),
	    functor(B, D, E),
	    A=..[F|G],
	    B=..[H|I],
	    copy_with_variable_replacement_l(G, I, C)
	).
copy_with_variable_replacement_l([], [], A).
copy_with_variable_replacement_l([A|B], [C|D], E) :-
	copy_with_variable_replacement(A, C, E),
	copy_with_variable_replacement_l(B, D, E).
variable_replacement(A, B, C) :-
	variable_replacement(A, B, [], C).
variable_replacement(A, B, C, D) :-
	(   var(A)
	->  var(B),
	    (   lookup_eq(C, A, E)
	    ->  E==B,
		D=C
	    ;   D=[A-B|C]
	    )
	;   A=..[F|G],
	    nonvar(B),
	    B=..[F|H],
	    variable_replacement_l(G, H, C, D)
	).
variable_replacement_l([], [], A, A).
variable_replacement_l([A|B], [C|D], E, F) :-
	variable_replacement(A, C, E, G),
	variable_replacement_l(B, D, G, F).
simplification_code(A, B, C, D, E/F, G, H, I) :-
	D=pragma(J, K, L, M),
	head_info(A, F, N, O, P, Q),
	build_head(E, F, G, P, R),
	head_arg_matches(Q, [], S, T),
	(   B==[]
	->  U=[],
	    V=T,
	    W=[]
	;   rest_heads_retrieval_and_matching(B, C, L, A, W, U, T, V)
	),
	guard_body_copies2(J, V, X, Y),
	guard_via_reschedule(W, X, R-S, Z),
	gen_uncond_susps_detachments(U, B, A1),
	gen_cond_susp_detachment(O, E/F, B1),
	(   chr_pp_flag(debugable, on)
	->  J=rule(C1, D1, E1, F1),
	    my_term_copy(E1-F1, V, G1, H1-I1),
	    J1='chr debug_event'(try([O|K1], [], H1, I1)),
	    L1='chr debug_event'(apply([O|K1], [], H1, I1))
	;   J1=true,
	    L1=true
	),
	M1= (R:-S, Z, J1, !, L1, A1, B1, Y),
	H=[M1|I].
head_arg_matches(A, B, C, D) :-
	head_arg_matches_(A, B, E, D),
	list2conj(E, C).
head_arg_matches_([], A, [], A).
head_arg_matches_([A-B|C], D, E, F) :-
	(   var(A)
	->  (   lookup_eq(D, A, G)
	    ->  E=[B==G|H],
		I=D
	    ;   I=[A-B|D],
		E=H
	    ),
	    J=C
	;   atomic(A)
	->  E=[B==A|H],
	    D=I,
	    J=C
	;   A=..[K|L],
	    functor(A, M, N),
	    functor(O, M, N),
	    O=..[P|Q],
	    E=[nonvar(B), B=O|H],
	    pairup(L, Q, R),
	    append(R, C, J),
	    I=D
	),
	head_arg_matches_(J, I, H, F).
rest_heads_retrieval_and_matching(A, B, C, D, E, F, G, H) :-
	rest_heads_retrieval_and_matching(A, B, C, D, E, F, G, H, [], [], []).
rest_heads_retrieval_and_matching(A, B, C, D, E, F, G, H, I, J, K) :-
	(   A=[L|M]
	->  rest_heads_retrieval_and_matching_n(A, B, C, I, J, D, E, F, G, H, K)
	;   E=[],
	    F=[],
	    G=H
	).
rest_heads_retrieval_and_matching_n([], A, B, C, D, E, [], [], F, F, G) :-
	instantiate_pattern_goals(G).
rest_heads_retrieval_and_matching_n([A|B], [C|D], E, F, G, H, [I, J|K], [L|M], N, O, P) :-
	passive_head_via(A, [H|F], P, N, I, Q, R),
	functor(A, S, T),
	head_info(A, T, U, V, W, X),
	head_arg_matches(X, N, Y, Z),
	A1=..[suspension, B1, C1, D1, E1, F1, G1|U],
	get_max_constraint_index(H1),
	(   H1==1
	->  I1=Q
	;   get_constraint_index(S/T, J1),
	    make_attr(H1, K1, L1, Q),
	    nth(J1, L1, I1)
	),
	different_from_other_susps(A, L, F, G, M1),
	create_get_mutable(active, C1, N1),
	O1= ('chr sbag_member'(L, I1), L=A1, N1, M1, Y),
	(   member(unique(C, P1), E),
	    check_unique_keys(P1, N)
	->  J= (O1->true)
	;   J=O1
	),
	rest_heads_retrieval_and_matching_n(B, D, E, [A|F], [L|G], H, K, M, Z, O, R).
instantiate_pattern_goals([]).
instantiate_pattern_goals([A-attr(B, C, D)|E]) :-
	get_max_constraint_index(F),
	(   F==1
	->  D=true
	;   make_attr(F, G, H, B),
	    or_list(C, I), !,
	    D= (G/\I=:=I)
	),
	instantiate_pattern_goals(E).
check_unique_keys([], A).
check_unique_keys([A|B], C) :-
	lookup_eq(C, A, D),
	check_unique_keys(B, C).
different_from_other_susps(A, B, C, D, E) :-
	(   bagof(F, G^ (nth(G, C, H), \+A\=H, nth(G, D, I), F= (B\==I)), J)
	->  list2conj(J, E)
	;   E=true
	).
passive_head_via(A, B, C, D, E, F, G) :-
	functor(A, H, I),
	get_constraint_index(H/I, J),
	common_variables(A, B, K),
	translate(K, D, L),
	or_pattern(J, M),
	(   permutation(L, N),
	    lookup_eq(C, N, attr(F, O, P))
	->  member(M, O), !,
	    G=C,
	    E=true
	;   E= (Q, R),
	    gen_get_mod_constraints(L, Q, F),
	    G=[L-attr(F, [M|S], R)|C]
	).
common_variables(A, B, C) :-
	term_variables(A, D),
	term_variables(B, E),
	intersect_eq(D, E, C).
gen_get_mod_constraints(A, B, C) :-
	get_target_module(D),
	(   A==[]
	->  B= ('chr global_term_ref_1'(E), get_attr(E, D, F), F=C)
	;   (   A=[G]
	    ->  H='chr via_1'(G, I)
	    ;   A=[G, J]
	    ->  H='chr via_2'(G, J, I)
	    ;   H='chr via'(A, I)
	    ),
	    B= (H, get_attr(I, D, F), F=C)
	).
guard_body_copies(A, B, C, D) :-
	guard_body_copies2(A, B, E, D),
	list2conj(E, C).
guard_body_copies2(A, B, C, D) :-
	A=rule(E, F, G, H),
	conj2list(G, I),
	split_off_simple_guard(I, B, J, K),
	my_term_copy(J-K, B, L, M-N),
	append(M, [O], C),
	term_variables(K, P),
	term_variables(N, Q),
	(   chr_pp_flag(guard_locks, on),
	    bagof('chr lock'(R)-'chr unlock'(R), S^ (member(S, P), lookup_eq(B, S, R), memberchk_eq(R, Q)), T)
	->  once(pairup(U, V, T))
	;   U=[],
	    V=[]
	),
	list2conj(U, W),
	list2conj(V, X),
	list2conj(N, Y),
	O= (W, Y, X),
	my_term_copy(H, L, D).
split_off_simple_guard([], A, [], []).
split_off_simple_guard([A|B], C, D, E) :-
	(   simple_guard(A, C)
	->  D=[A|F],
	    split_off_simple_guard(B, C, F, E)
	;   D=[],
	    E=[A|B]
	).
simple_guard(var(A), B).
simple_guard(nonvar(A), B).
simple_guard(ground(A), B).
simple_guard(number(A), B).
simple_guard(atom(A), B).
simple_guard(integer(A), B).
simple_guard(float(A), B).
simple_guard(A>B, C).
simple_guard(A<B, C).
simple_guard(A=<B, C).
simple_guard(A>=B, C).
simple_guard(A=:=B, C).
simple_guard(A==B, C).
simple_guard(A is B, C) :-
	\+lookup_eq(C, A, D).
simple_guard((A, B), C) :-
	simple_guard(A, C),
	simple_guard(B, C).
simple_guard(\+A, B) :-
	simple_guard(A, B).
my_term_copy(A, B, C) :-
	my_term_copy(A, B, D, C).
my_term_copy(A, B, C, D) :-
	(   var(A)
	->  (   lookup_eq(B, A, D)
	    ->  C=B
	    ;   C=[A-D|B]
	    )
	;   functor(A, E, F),
	    functor(D, E, F),
	    A=..[G|H],
	    D=..[I|J],
	    my_term_copy_list(H, B, C, J)
	).
my_term_copy_list([], A, A, []).
my_term_copy_list([A|B], C, D, [E|F]) :-
	my_term_copy(A, C, G, E),
	my_term_copy_list(B, G, D, F).
gen_cond_susp_detachment(A, B, C) :-
	(   is_attached(B)
	->  gen_uncond_susp_detachment(A, B, D),
	    C= (var(A)->true;D)
	;   C=true
	).
gen_uncond_susp_detachment(A, B/C, D) :-
	(   is_attached(B/C)
	->  atom_concat_list([detach_, B, /, C], E),
	    F=..[E, G, A],
	    (   chr_pp_flag(debugable, on)
	    ->  H='chr debug_event'(remove(A))
	    ;   H=true
	    ),
	    D= (H, 'chr remove_constraint_internal'(A, G), F)
	;   D=true
	).
gen_uncond_susps_detachments([], [], true).
gen_uncond_susps_detachments([A|B], [C|D], (E, F)) :-
	functor(C, G, H),
	gen_uncond_susp_detachment(A, G/H, E),
	gen_uncond_susps_detachments(B, D, F).
simpagation_head1_code(A, B, C, D, E/F, G, H, I) :-
	D=pragma(J, ids(K, L), M, N),
	J=rule(O, P, Q, R),
	head_info(A, F, S, T, U, V),
	head_arg_matches(V, [], W, X),
	build_head(E, F, G, U, Y),
	append(B, P, Z),
	append(C, L, A1),
	reorder_heads(A, Z, A1, B1, C1),
	rest_heads_retrieval_and_matching(B1, C1, M, A, D1, E1, X, F1),
	split_by_ids(C1, E1, C, G1, H1),
	guard_body_copies2(J, F1, I1, J1),
	guard_via_reschedule(D1, I1, Y-W, K1),
	gen_uncond_susps_detachments(G1, B, L1),
	gen_cond_susp_detachment(T, E/F, M1),
	(   chr_pp_flag(debugable, on)
	->  my_term_copy(Q-R, F1, N1, O1-P1),
	    Q1='chr debug_event'(try([T|G1], H1, O1, P1)),
	    R1='chr debug_event'(apply([T|G1], H1, O1, P1))
	;   Q1=true,
	    R1=true
	),
	S1= (Y:-W, K1, Q1, !, R1, L1, M1, J1),
	H=[S1|I].
split_by_ids([], [], A, [], []).
split_by_ids([A|B], [C|D], E, F, G) :-
	(   memberchk_eq(A, E)
	->  F=[C|H],
	    G=I
	;   F=H,
	    G=[C|I]
	),
	split_by_ids(B, D, E, H, I).
simpagation_head2_code(A, B, C, D, E, F, G, H) :-
	D=pragma(I, ids(J, K), L, M),
	I=rule(N, O, P, Q),
	reorder_heads(A, N, J, [R|S], [T|U]),
	simpagation_head2_prelude(A, R, [B, N, P, Q], E, F, G, V),
	extend_id(F, W),
	simpagation_head2_worker(A, R, T, S, U, B, C, I, L, E, W, V, H).
simpagation_head2_prelude(A, B, C, D/E, F, G, H) :-
	head_info(A, E, I, J, K, L),
	build_head(D, E, F, K, M),
	head_arg_matches(L, [], N, O),
	passive_head_via(B, [A], [], O, P, Q, R),
	instantiate_pattern_goals(R),
	get_max_constraint_index(S),
	(   S==1
	->  T=Q
	;   functor(B, U, V),
	    get_constraint_index(U/V, W),
	    make_attr(S, X, Y, Q),
	    nth(W, Y, T)
	),
	(   F==[0]
	->  gen_cond_allocation(I, J, D/E, K, Z)
	;   Z=true
	),
	extend_id(F, A1),
	extra_active_delegate_variables(A, C, O, B1),
	append([T|K], B1, C1),
	build_head(D, E, A1, C1, D1),
	E1= (M:-N, P, !, Z, D1),
	G=[E1|H].
extra_active_delegate_variables(A, B, C, D) :-
	A=..[E|F],
	delegate_variables(A, B, C, F, D).
passive_delegate_variables(A, B, C, D, E) :-
	term_variables(B, F),
	delegate_variables(A, C, D, F, E).
delegate_variables(A, B, C, D, E) :-
	term_variables(A, F),
	term_variables(B, G),
	intersect_eq(F, G, H),
	list_difference_eq(H, D, I),
	translate(I, C, E).
simpagation_head2_worker(A, B, C, D, E, F, G, H, I, J, K, L, M) :-
	H=rule(N, O, P, Q),
	simpagation_head2_worker_end(A, [B, D, F, P, Q], J, K, L, R),
	simpagation_head2_worker_body(A, B, C, D, E, F, G, H, I, J, K, R, M).
simpagation_head2_worker_body(A, B, C, D, E, F, G, H, I, J/K, L, M, N) :-
	gen_var(O),
	gen_var(P),
	head_info(A, K, Q, R, S, T),
	head_arg_matches(T, [], U, V),
	H=rule(W, X, Y, Z),
	extra_active_delegate_variables(A, [B, D, F, Y, Z], V, A1),
	append([[O|P]|S], A1, B1),
	build_head(J, K, L, B1, C1),
	functor(B, D1, E1),
	head_info(B, E1, F1, G1, H1, I1),
	head_arg_matches(I1, V, J1, K1),
	L1=..[suspension, M1, N1, O1, P1, Q1, R1|F1],
	create_get_mutable(active, N1, S1),
	T1= (O=L1, S1),
	(   (   D\==[]
	    ;   F\==[]
	    )
	->  append(D, F, U1),
	    append(E, G, V1),
	    reorder_heads(B-A, U1, V1, W1, X1),
	    rest_heads_retrieval_and_matching(W1, X1, I, [B, A], Y1, Z1, K1, A2, [B], [O], []),
	    split_by_ids(X1, Z1, E, B2, C2)
	;   Y1=[],
	    B2=[],
	    C2=[],
	    A2=K1
	),
	gen_uncond_susps_detachments([O|B2], [B|D], D2),
	append([P|S], A1, E2),
	build_head(J, K, L, E2, F2),
	append([[]|S], A1, G2),
	build_head(J, K, L, G2, H2),
	guard_body_copies2(H, A2, I2, J2),
	guard_via_reschedule(Y1, I2, v(C1, T1, J1), K2),
	(   J2\==true
	->  gen_uncond_attach_goal(J/K, R, L2, M2),
	    gen_state_cond_call(R, K, F2, M2, N2),
	    gen_state_cond_call(R, K, H2, M2, O2)
	;   L2=true,
	    N2=F2,
	    O2=H2
	),
	(   chr_pp_flag(debugable, on)
	->  my_term_copy(Y-Z, A2, P2, Q2-R2),
	    S2='chr debug_event'(try([O|B2], [R|C2], Q2, R2)),
	    T2='chr debug_event'(apply([O|B2], [R|C2], Q2, R2))
	;   S2=true,
	    T2=true
	),
	(   member(unique(C, U2), I),
	    check_unique_keys(U2, V)
	->  V2= (C1:-T1, J1-> (K2, S2->T2, D2, L2, J2, O2;H2);F2)
	;   V2= (C1:-T1, J1, K2, S2->T2, D2, L2, J2, N2;F2)
	),
	M=[V2|N].
gen_state_cond_call(A, B, C, D, E) :-
	length(F, B),
	G=..[suspension, H, I, J, K, L, M|F],
	create_get_mutable(active, I, N),
	create_get_mutable(D, K, O),
	E= (A=G, N, O->'chr update_mutable'(inactive, I), C;true).
simpagation_head2_worker_end(A, B, C/D, E, F, G) :-
	head_info(A, D, H, I, J, K),
	head_arg_matches(K, [], L, M),
	extra_active_delegate_variables(A, B, M, N),
	append([[]|J], N, O),
	build_head(C, D, E, O, P),
	next_id(E, Q),
	build_head(C, D, Q, J, R),
	S= (P:-R),
	F=[S|G].
propagation_code(A, B, C, D, E, F, G, H, I) :-
	(   B==[]
	->  propagation_single_headed(A, C, D, F, G, H, I)
	;   propagation_multi_headed(A, B, C, D, E, F, G, H, I)
	).
propagation_single_headed(A, B, C, D/E, F, G, H) :-
	head_info(A, E, I, J, K, L),
	build_head(D, E, F, K, M),
	inc_id(F, N),
	build_head(D, E, N, K, O),
	P=O,
	head_arg_matches(L, [], Q, R),
	guard_body_copies(B, R, S, T),
	(   F==[0]
	->  gen_cond_allocation(I, J, D/E, K, U),
	    V=U
	;   V=true
	),
	gen_uncond_attach_goal(D/E, J, W, X),
	gen_state_cond_call(J, E, P, X, Y),
	(   chr_pp_flag(debugable, on)
	->  B=rule(Z, A1, B1, C1),
	    my_term_copy(B1-C1, R, D1, E1-F1),
	    G1='chr debug_event'(try([], [J], E1, F1)),
	    H1='chr debug_event'(apply([], [J], E1, F1))
	;   G1=true,
	    H1=true
	),
	I1= (M:-Q, V, 'chr novel_production'(J, C), S, G1, !, H1, 'chr extend_history'(J, C), W, T, Y),
	G=[I1|H].
propagation_multi_headed(A, B, C, D, E, F, G, H, I) :-
	B=[J|K],
	propagation_prelude(A, B, C, F, G, H, L),
	extend_id(G, M),
	propagation_nested_code(K, [J, A], C, D, E, F, M, L, I).
propagation_prelude(A, [B|C], D, E/F, G, H, I) :-
	head_info(A, F, J, K, L, M),
	build_head(E, F, G, L, N),
	head_arg_matches(M, [], O, P),
	D=rule(Q, R, S, T),
	extra_active_delegate_variables(A, [B, C, S, T], P, U),
	passive_head_via(B, [A], [], P, V, W, X),
	instantiate_pattern_goals(X),
	get_max_constraint_index(Y),
	(   Y==1
	->  Z=W
	;   functor(B, A1, B1),
	    make_attr(Y, C1, D1, W),
	    get_constraint_index(A1/B1, E1),
	    nth(E1, D1, Z)
	),
	(   G==[0]
	->  gen_cond_allocation(J, K, E/F, L, F1)
	;   F1=true
	),
	extend_id(G, G1),
	append([Z|L], U, H1),
	build_head(E, F, G1, H1, I1),
	J1=I1,
	K1= (N:-O, V, !, F1, J1),
	H=[K1|I].
propagation_nested_code([], [A|B], C, D, E, F, G, H, I) :-
	propagation_end([A|B], [], C, F, G, H, J),
	propagation_body(A, B, C, D, E, F, G, J, I).
propagation_nested_code([A|B], C, D, E, F, G, H, I, J) :-
	propagation_end(C, [A|B], D, G, H, I, K),
	propagation_accumulator([A|B], C, D, G, H, K, L),
	inc_id(H, M),
	propagation_nested_code(B, [A|C], D, E, F, G, M, L, J).
propagation_body(A, B, C, D, E, F/G, H, I, J) :-
	C=rule(K, L, M, N),
	get_prop_inner_loop_vars(B, [A, M, N], O, P, Q, R),
	gen_var(S),
	gen_var(T),
	functor(A, U, V),
	gen_vars(V, W),
	X=..[suspension, Y, Z, A1, B1, C1, D1|W],
	create_get_mutable(active, Z, E1),
	F1= (S=X, E1),
	G1=[[S|T]|O],
	build_head(F, G, H, G1, H1),
	I1=[T|O],
	build_head(F, G, H, I1, J1),
	K1=J1,
	A=..[L1|M1],
	pairup(M1, W, N1),
	head_arg_matches(N1, P, O1, P1),
	different_from_other_susps(A, S, B, R, Q1),
	guard_body_copies(C, P1, R1, S1),
	gen_uncond_attach_goal(F/G, Q, T1, U1),
	gen_state_cond_call(Q, G, K1, U1, V1),
	history_susps(E, [S|R], Q, [], W1),
	bagof('chr novel_production'(X1, Y1), (member(X1, W1), Y1=Z1), A2),
	list2conj(A2, B2),
	C2=..[t, D|W1],
	(   chr_pp_flag(debugable, on)
	->  C=rule(D2, E2, M, N),
	    my_term_copy(M-N, P1, F2, G2-H2),
	    I2='chr debug_event'(try([], [Q, S|R], G2, H2)),
	    J2='chr debug_event'(apply([], [Q, S|R], G2, H2))
	;   I2=true,
	    J2=true
	),
	K2= (H1:-F1, Q1, O1, Z1=C2, B2, R1, I2->J2, 'chr extend_history'(Q, Z1), T1, S1, V1;K1),
	I=[K2|J].
history_susps(A, B, C, D, E) :-
	(   A==0
	->  reverse(B, F),
	    append(F, [C|D], E)
	;   B=[G|H],
	    I is A-1,
	    history_susps(I, H, C, [G|D], E)
	).
get_prop_inner_loop_vars([A], B, C, D, E, []) :- !,
	functor(A, F, G),
	head_info(A, G, H, E, I, J),
	head_arg_matches(J, [], K, D),
	extra_active_delegate_variables(A, B, D, L),
	append(I, L, C).
get_prop_inner_loop_vars([A|B], C, D, E, F, [G|H]) :-
	get_prop_inner_loop_vars(B, [A|C], I, J, F, H),
	functor(A, K, L),
	gen_var(M),
	head_info(A, L, N, G, O, P),
	head_arg_matches(P, J, Q, E),
	passive_delegate_variables(A, B, C, E, R),
	append(R, [G, M|I], D).
propagation_end([A|B], C, D, E/F, G, H, I) :-
	D=rule(J, K, L, M),
	gen_var_susp_list_for(B, [A, C, L, M], N, O, P, Q),
	R=[[]|O],
	build_head(E, F, G, R, S),
	(   G=[0|T]
	->  next_id(G, U),
	    V=P
	;   dec_id(G, U),
	    V=[Q|P]
	),
	build_head(E, F, U, V, W),
	X=W,
	Y= (S:-X),
	H=[Y|I].
gen_var_susp_list_for([A], B, C, D, E, F) :- !,
	functor(A, G, H),
	head_info(A, H, I, F, E, J),
	head_arg_matches(J, [], K, C),
	extra_active_delegate_variables(A, B, C, L),
	append(E, L, D).
gen_var_susp_list_for([A|B], C, D, E, F, G) :-
	gen_var_susp_list_for(B, [A|C], H, F, I, J),
	functor(A, K, L),
	gen_var(G),
	head_info(A, L, M, N, O, P),
	head_arg_matches(P, H, Q, D),
	passive_delegate_variables(A, B, C, D, R),
	append(R, [N, G|F], E).
propagation_accumulator([A|B], [C|D], E, F/G, H, I, J) :-
	E=rule(K, L, M, N),
	pre_vars_and_susps(D, [C, A, B, M, N], O, P, Q),
	gen_var(R),
	functor(C, S, T),
	gen_vars(T, U),
	head_info(C, T, U, V, W, X),
	head_arg_matches(X, P, Y, Z),
	A1=..[suspension, B1, C1, D1, E1, F1, G1|U],
	different_from_other_susps(C, V, D, Q, H1),
	create_get_mutable(active, C1, I1),
	J1= (V=A1, I1, H1, Y),
	functor(A, K1, L1),
	passive_head_via(A, [C|D], [], Z, M1, N1, O1),
	instantiate_pattern_goals(O1),
	get_max_constraint_index(P1),
	(   P1==1
	->  Q1=N1
	;   get_constraint_index(K1/L1, R1),
	    make_attr(P1, S1, T1, N1),
	    nth(R1, T1, Q1)
	),
	inc_id(H, U1),
	V1=[[V|R]|O],
	build_head(F, G, H, V1, W1),
	passive_delegate_variables(C, D, [A, B, M, N], Z, X1),
	append([Q1|X1], [V, R|O], Y1),
	build_head(F, G, U1, Y1, Z1),
	A2=[R|O],
	build_head(F, G, H, A2, B2),
	C2= (W1:-J1, M1->Z1;B2),
	I=[C2|J].
pre_vars_and_susps([A], B, C, D, []) :- !,
	functor(A, E, F),
	head_info(A, F, G, H, I, J),
	head_arg_matches(J, [], K, D),
	extra_active_delegate_variables(A, B, D, L),
	append(I, L, C).
pre_vars_and_susps([A|B], C, D, E, [F|G]) :-
	pre_vars_and_susps(B, [A|C], H, I, G),
	functor(A, J, K),
	gen_var(L),
	head_info(A, K, M, F, N, O),
	head_arg_matches(O, I, P, E),
	passive_delegate_variables(A, B, C, E, Q),
	append(Q, [F, L|H], D).
reorder_heads(A, B, C, D, E) :-
	(   chr_pp_flag(reorder_heads, on)
	->  reorder_heads_main(A, B, C, D, E)
	;   D=B,
	    E=C
	).
reorder_heads_main(A, B, C, D, E) :-
	term_variables(A, F),
	reorder_heads1(B, C, F, D, E).
reorder_heads1(A, B, C, D, E) :-
	(   A==[]
	->  D=[],
	    E=[]
	;   D=[F|G],
	    E=[H|I],
	    select_best_head(A, B, C, F, H, J, K, L),
	    reorder_heads1(J, K, L, G, I)
	).
select_best_head(A, B, C, D, E, F, G, H) :-
	(   bagof(tuple(I, J, K, L, M), (select2(J, K, A, B, L, M), order_score(J, C, L, I)), N)
	->  true
	;   N=[]
	),
	max_go_list(N, tuple(O, D, E, F, G)),
	term_variables(D, P),
	(   setof(Q, (member(Q, P), \+memberchk_eq(Q, C)), R)
	->  true
	;   R=[]
	),
	append(R, C, H).
reorder_heads(A, B, C) :-
	term_variables(A, D),
	reorder_heads1(B, D, C).
reorder_heads1(A, B, C) :-
	(   A==[]
	->  C=[]
	;   C=[D|E],
	    select_best_head(A, B, D, F, G),
	    reorder_heads1(F, G, E)
	).
select_best_head(A, B, C, D, E) :-
	(   bagof(tuple(F, G, H), (select(G, A, H), order_score(G, B, H, F)), I)
	->  true
	;   I=[]
	),
	max_go_list(I, tuple(J, C, D)),
	term_variables(C, K),
	(   setof(L, (member(L, K), \+memberchk_eq(L, B)), M)
	->  true
	;   M=[]
	),
	append(M, B, E).
order_score(A, B, C, D) :-
	term_variables(A, E),
	term_variables(C, F),
	order_score_vars(E, B, F, 0, D).
order_score_vars([], A, B, C, D) :-
	(   C==0
	->  D=99999
	;   D=C
	).
order_score_vars([A|B], C, D, E, F) :-
	(   memberchk_eq(A, C)
	->  G is E+1
	;   memberchk_eq(A, D)
	->  G is E+1
	;   G=E
	),
	order_score_vars(B, C, D, G, F).
create_get_mutable(A, B, C) :-
	C= (B=mutable(A)).
clean_clauses([], []).
clean_clauses([A|B], [C|D]) :-
	clean_clause(A, C),
	clean_clauses(B, D).
clean_clause(A, B) :-
	(   A= (C:-D)
	->  clean_goal(D, E),
	    (   E==true
	    ->  B=C
	    ;   B= (C:-E)
	    )
	;   B=A
	).
clean_goal(A, B) :-
	var(A), !,
	B=A.
clean_goal((A, B), C) :- !,
	clean_goal(A, D),
	clean_goal(B, E),
	(   D==true
	->  C=E
	;   E==true
	->  C=D
	;   C= (D, E)
	).
clean_goal((A->B;C), D) :- !,
	clean_goal(A, E),
	(   E==true
	->  clean_goal(B, F),
	    D=F
	;   E==fail
	->  clean_goal(C, G),
	    D=G
	;   clean_goal(B, F),
	    clean_goal(C, G),
	    D= (E->F;G)
	).
clean_goal((A;B), C) :- !,
	clean_goal(A, D),
	clean_goal(B, E),
	(   D==fail
	->  C=E
	;   E==fail
	->  C=D
	;   C= (D;E)
	).
clean_goal(once(A), B) :- !,
	clean_goal(A, C),
	(   C==true
	->  B=true
	;   C==fail
	->  B=fail
	;   B=once(C)
	).
clean_goal((A->B), C) :- !,
	clean_goal(A, D),
	(   D==true
	->  clean_goal(B, C)
	;   D==fail
	->  C=fail
	;   clean_goal(B, E),
	    C= (D->E)
	).
clean_goal(A, A).
gen_var(A).
gen_vars(A, B) :-
	length(B, A).
head_info(A, B, C, D, E, F) :-
	vars_susp(B, C, D, E),
	A=..[G|H],
	pairup(H, C, F).
inc_id([A|B], [C|B]) :-
	C is A+1.
dec_id([A|B], [C|B]) :-
	C is A-1.
extend_id(A, [0|A]).
next_id([A, B|C], [D|C]) :-
	D is B+1.
build_head(A, B, C, D, E) :-
	buildName(A, B, C, F),
	E=..[F|D].
buildName(A, B, C, D) :-
	atom_concat(A, /, E),
	atom_concat(E, B, F),
	buildName_(C, F, D).
buildName_([], A, A).
buildName_([A|B], C, D) :-
	buildName_(B, C, E),
	atom_concat(E, '__', F),
	atom_concat(F, A, D).
vars_susp(A, B, C, D) :-
	length(B, A),
	append(B, [C], D).
make_attr(A, B, C, D) :-
	length(C, A),
	D=..[v, B|C].
or_pattern(A, B) :-
	C is A-1,
	B is 1<<C.
and_pattern(A, B) :-
	C is A-1,
	D is 1<<C,
	B is-1* (D+1).
conj2list(A, B) :-
	conj2list(A, B, []).
conj2list(A, B, C) :-
	A= (D, E), !,
	conj2list(D, B, F),
	conj2list(E, F, C).
conj2list(A, [A|B], B).
list2conj([], true).
list2conj([A], B) :- !,
	B=A.
list2conj([A|B], C) :-
	(   A==true
	->  list2conj(B, C)
	;   C= (A, D),
	    list2conj(B, D)
	).
atom_concat_list([A], A) :- !.
atom_concat_list([A|B], C) :-
	atom_concat_list(B, D),
	atom_concat(A, D, C).
set_elems([], A).
set_elems([A|B], A) :-
	set_elems(B, A).
member2([A|B], [C|D], A-C).
member2([A|B], [C|D], E) :-
	member2(B, D, E).
select2(A, B, [A|C], [B|D], C, D).
select2(A, B, [C|D], [E|F], [C|G], [E|H]) :-
	select2(A, B, D, F, G, H).
pair_all_with([], A, []).
pair_all_with([A|B], C, [A-C|D]) :-
	pair_all_with(B, C, D).
'attach_constraint/2'([], A).
'attach_constraint/2'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\1=:=1
	    ->  put_attr(A, chr_translate_bootstrap1, v(E, [C|F], G, H, I, J, K))
	    ;   L is E\/1,
		put_attr(A, chr_translate_bootstrap1, v(L, [C], G, H, I, J, K))
	    )
	;   put_attr(A, chr_translate_bootstrap1, v(1, [C], [], [], [], [], []))
	),
	'attach_constraint/2'(B, C).
'detach_constraint/2'([], A).
'detach_constraint/2'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\1=:=1
	    ->  'chr sbag_del_element'(F, C, L),
		(   L==[]
		->  M is E/\ -2,
		    (   M==0
		    ->  del_attr(A, chr_translate_bootstrap1)
		    ;   put_attr(A, chr_translate_bootstrap1, v(M, [], G, H, I, J, K))
		    )
		;   put_attr(A, chr_translate_bootstrap1, v(E, L, G, H, I, J, K))
		)
	    ;   true
	    )
	;   true
	),
	'detach_constraint/2'(B, C).
'attach_constraint_count/1'([], A).
'attach_constraint_count/1'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\2=:=2
	    ->  put_attr(A, chr_translate_bootstrap1, v(E, F, [C|G], H, I, J, K))
	    ;   L is E\/2,
		put_attr(A, chr_translate_bootstrap1, v(L, F, [C], H, I, J, K))
	    )
	;   put_attr(A, chr_translate_bootstrap1, v(2, [], [C], [], [], [], []))
	),
	'attach_constraint_count/1'(B, C).
'detach_constraint_count/1'([], A).
'detach_constraint_count/1'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\2=:=2
	    ->  'chr sbag_del_element'(G, C, L),
		(   L==[]
		->  M is E/\ -3,
		    (   M==0
		    ->  del_attr(A, chr_translate_bootstrap1)
		    ;   put_attr(A, chr_translate_bootstrap1, v(M, F, [], H, I, J, K))
		    )
		;   put_attr(A, chr_translate_bootstrap1, v(E, F, L, H, I, J, K))
		)
	    ;   true
	    )
	;   true
	),
	'detach_constraint_count/1'(B, C).
'attach_constraint_index/2'([], A).
'attach_constraint_index/2'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\4=:=4
	    ->  put_attr(A, chr_translate_bootstrap1, v(E, F, G, [C|H], I, J, K))
	    ;   L is E\/4,
		put_attr(A, chr_translate_bootstrap1, v(L, F, G, [C], I, J, K))
	    )
	;   put_attr(A, chr_translate_bootstrap1, v(4, [], [], [C], [], [], []))
	),
	'attach_constraint_index/2'(B, C).
'detach_constraint_index/2'([], A).
'detach_constraint_index/2'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\4=:=4
	    ->  'chr sbag_del_element'(H, C, L),
		(   L==[]
		->  M is E/\ -5,
		    (   M==0
		    ->  del_attr(A, chr_translate_bootstrap1)
		    ;   put_attr(A, chr_translate_bootstrap1, v(M, F, G, [], I, J, K))
		    )
		;   put_attr(A, chr_translate_bootstrap1, v(E, F, G, L, I, J, K))
		)
	    ;   true
	    )
	;   true
	),
	'detach_constraint_index/2'(B, C).
'attach_max_constraint_index/1'([], A).
'attach_max_constraint_index/1'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\8=:=8
	    ->  put_attr(A, chr_translate_bootstrap1, v(E, F, G, H, [C|I], J, K))
	    ;   L is E\/8,
		put_attr(A, chr_translate_bootstrap1, v(L, F, G, H, [C], J, K))
	    )
	;   put_attr(A, chr_translate_bootstrap1, v(8, [], [], [], [C], [], []))
	),
	'attach_max_constraint_index/1'(B, C).
'detach_max_constraint_index/1'([], A).
'detach_max_constraint_index/1'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\8=:=8
	    ->  'chr sbag_del_element'(I, C, L),
		(   L==[]
		->  M is E/\ -9,
		    (   M==0
		    ->  del_attr(A, chr_translate_bootstrap1)
		    ;   put_attr(A, chr_translate_bootstrap1, v(M, F, G, H, [], J, K))
		    )
		;   put_attr(A, chr_translate_bootstrap1, v(E, F, G, H, L, J, K))
		)
	    ;   true
	    )
	;   true
	),
	'detach_max_constraint_index/1'(B, C).
'attach_target_module/1'([], A).
'attach_target_module/1'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\16=:=16
	    ->  put_attr(A, chr_translate_bootstrap1, v(E, F, G, H, I, [C|J], K))
	    ;   L is E\/16,
		put_attr(A, chr_translate_bootstrap1, v(L, F, G, H, I, [C], K))
	    )
	;   put_attr(A, chr_translate_bootstrap1, v(16, [], [], [], [], [C], []))
	),
	'attach_target_module/1'(B, C).
'detach_target_module/1'([], A).
'detach_target_module/1'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\16=:=16
	    ->  'chr sbag_del_element'(J, C, L),
		(   L==[]
		->  M is E/\ -17,
		    (   M==0
		    ->  del_attr(A, chr_translate_bootstrap1)
		    ;   put_attr(A, chr_translate_bootstrap1, v(M, F, G, H, I, [], K))
		    )
		;   put_attr(A, chr_translate_bootstrap1, v(E, F, G, H, I, L, K))
		)
	    ;   true
	    )
	;   true
	),
	'detach_target_module/1'(B, C).
'attach_attached/2'([], A).
'attach_attached/2'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\32=:=32
	    ->  put_attr(A, chr_translate_bootstrap1, v(E, F, G, H, I, J, [C|K]))
	    ;   L is E\/32,
		put_attr(A, chr_translate_bootstrap1, v(L, F, G, H, I, J, [C]))
	    )
	;   put_attr(A, chr_translate_bootstrap1, v(32, [], [], [], [], [], [C]))
	),
	'attach_attached/2'(B, C).
'detach_attached/2'([], A).
'detach_attached/2'([A|B], C) :-
	(   get_attr(A, chr_translate_bootstrap1, D)
	->  D=v(E, F, G, H, I, J, K),
	    (   E/\32=:=32
	    ->  'chr sbag_del_element'(K, C, L),
		(   L==[]
		->  M is E/\ -33,
		    (   M==0
		    ->  del_attr(A, chr_translate_bootstrap1)
		    ;   put_attr(A, chr_translate_bootstrap1, v(M, F, G, H, I, J, []))
		    )
		;   put_attr(A, chr_translate_bootstrap1, v(E, F, G, H, I, J, L))
		)
	    ;   true
	    )
	;   true
	),
	'detach_attached/2'(B, C).
attach_increment([], A).
attach_increment([A|B], v(C, D, E, F, G, H, I)) :-
	'chr not_locked'(A),
	(   get_attr(A, chr_translate_bootstrap1, J)
	->  J=v(K, L, M, N, O, P, Q),
	    sort(L, R),
	    'chr merge_attributes'(D, R, S),
	    sort(M, T),
	    'chr merge_attributes'(E, T, U),
	    sort(N, V),
	    'chr merge_attributes'(F, V, W),
	    sort(O, X),
	    'chr merge_attributes'(G, X, Y),
	    sort(P, Z),
	    'chr merge_attributes'(H, Z, A1),
	    sort(Q, B1),
	    'chr merge_attributes'(I, B1, C1),
	    D1 is C\/K,
	    put_attr(A, chr_translate_bootstrap1, v(D1, S, U, W, Y, A1, C1))
	;   put_attr(A, chr_translate_bootstrap1, v(C, D, E, F, G, H, I))
	),
	attach_increment(B, v(C, D, E, F, G, H, I)).
chr_translate_bootstrap1:attr_unify_hook(v(A, B, C, D, E, F, G), H) :-
	sort(B, I),
	sort(C, J),
	sort(D, K),
	sort(E, L),
	sort(F, M),
	sort(G, N),
	(   var(H)
	->  (   get_attr(H, chr_translate_bootstrap1, O)
	    ->  O=v(P, Q, R, S, T, U, V),
		sort(Q, W),
		'chr merge_attributes'(I, W, X),
		sort(R, Y),
		'chr merge_attributes'(J, Y, Z),
		sort(S, A1),
		'chr merge_attributes'(K, A1, B1),
		sort(T, C1),
		'chr merge_attributes'(L, C1, D1),
		sort(U, E1),
		'chr merge_attributes'(M, E1, F1),
		sort(V, G1),
		'chr merge_attributes'(N, G1, H1),
		I1 is A\/P,
		put_attr(H, chr_translate_bootstrap1, v(I1, X, Z, B1, D1, F1, H1)),
		'chr run_suspensions_loop'([X, Z, B1, D1, F1, H1])
	    ;   put_attr(H, chr_translate_bootstrap1, v(A, I, J, K, L, M, N)),
		'chr run_suspensions_loop'([I, J, K, L, M, N])
	    )
	;   (   compound(H)
	    ->  term_variables(H, J1),
		attach_increment(J1, v(A, I, J, K, L, M, N))
	    ;   true
	    ),
	    'chr run_suspensions_loop'([I, J, K, L, M, N])
	).
constraint(A, B) :-
	'constraint/2__0'(A, B, C).
'constraint/2__0'(A, B, C) :-
	'chr via_1'(A, D),
	get_attr(D, chr_translate_bootstrap1, E),
	E=v(F, G, H, I, J, K, L),
	F/\1=:=1,
	(   'chr sbag_member'(M, G),
	    M=suspension(N, O, P, Q, R, S, T, U),
	    O=mutable(active),
	    T==A
	->  true
	), !,
	(   var(C)
	->  true
	;   'chr remove_constraint_internal'(C, V),
	    'detach_constraint/2'(V, C)
	),
	B=U.
'constraint/2__0'(A, B, C) :-
	'chr via_1'(B, D),
	get_attr(D, chr_translate_bootstrap1, E),
	E=v(F, G, H, I, J, K, L),
	F/\1=:=1,
	'chr sbag_member'(M, G),
	M=suspension(N, O, P, Q, R, S, T, U),
	O=mutable(active),
	U==B, !,
	(   var(C)
	->  true
	;   'chr remove_constraint_internal'(C, V),
	    'detach_constraint/2'(V, C)
	),
	A=T.
'constraint/2__0'(A, B, C) :-
	(   var(C)
	->  'chr insert_constraint_internal'(D, C, chr_translate_bootstrap1:'constraint/2__0'(A, B, C), constraint, [A, B])
	;   'chr activate_constraint'(D, C, E)
	),
	'attach_constraint/2'(D, C).
constraint_count(A) :-
	'constraint_count/1__0'(A, B).
'constraint_count/1__0'(A, B) :-
	'chr global_term_ref_1'(C),
	get_attr(C, chr_translate_bootstrap1, D),
	D=v(E, F, G, H, I, J, K),
	E/\2=:=2,
	'chr sbag_member'(L, G),
	L=suspension(M, N, O, P, Q, R, S),
	N=mutable(active), !,
	(   var(B)
	->  true
	;   'chr remove_constraint_internal'(B, T),
	    'detach_constraint_count/1'(T, B)
	),
	A=S.
'constraint_count/1__0'(A, B) :-
	(   var(B)
	->  'chr insert_constraint_internal'(C, B, chr_translate_bootstrap1:'constraint_count/1__0'(A, B), constraint_count, [A])
	;   'chr activate_constraint'(C, B, D)
	),
	'attach_constraint_count/1'(C, B).
constraint_index(A, B) :-
	'constraint_index/2__0'(A, B, C).
'constraint_index/2__0'(A, B, C) :-
	(   var(C)
	->  'chr insert_constraint_internal'(D, C, chr_translate_bootstrap1:'constraint_index/2__0'(A, B, C), constraint_index, [A, B])
	;   'chr activate_constraint'(D, C, E)
	),
	'attach_constraint_index/2'(D, C).
get_constraint_index(A, B) :-
	'get_constraint_index/2__0'(A, B, C).
'get_constraint_index/2__0'(A, B, C) :-
	'chr via_1'(A, D),
	get_attr(D, chr_translate_bootstrap1, E),
	E=v(F, G, H, I, J, K, L),
	F/\4=:=4,
	'chr sbag_member'(M, I),
	M=suspension(N, O, P, Q, R, S, T, U),
	O=mutable(active),
	T==A, !,
	B=U.
'get_constraint_index/2__0'(A, B, C) :- !,
	fail.
max_constraint_index(A) :-
	'max_constraint_index/1__0'(A, B).
'max_constraint_index/1__0'(A, B) :-
	(   var(B)
	->  'chr insert_constraint_internal'(C, B, chr_translate_bootstrap1:'max_constraint_index/1__0'(A, B), max_constraint_index, [A])
	;   'chr activate_constraint'(C, B, D)
	),
	'attach_max_constraint_index/1'(C, B).
get_max_constraint_index(A) :-
	'get_max_constraint_index/1__0'(A, B).
'get_max_constraint_index/1__0'(A, B) :-
	'chr global_term_ref_1'(C),
	get_attr(C, chr_translate_bootstrap1, D),
	D=v(E, F, G, H, I, J, K),
	E/\8=:=8,
	'chr sbag_member'(L, I),
	L=suspension(M, N, O, P, Q, R, S),
	N=mutable(active), !,
	A=S.
'get_max_constraint_index/1__0'(A, B) :- !,
	fail.
target_module(A) :-
	'target_module/1__0'(A, B).
'target_module/1__0'(A, B) :-
	(   var(B)
	->  'chr insert_constraint_internal'(C, B, chr_translate_bootstrap1:'target_module/1__0'(A, B), target_module, [A])
	;   'chr activate_constraint'(C, B, D)
	),
	'attach_target_module/1'(C, B).
get_target_module(A) :-
	'get_target_module/1__0'(A, B).
'get_target_module/1__0'(A, B) :-
	'chr global_term_ref_1'(C),
	get_attr(C, chr_translate_bootstrap1, D),
	D=v(E, F, G, H, I, J, K),
	E/\16=:=16,
	'chr sbag_member'(L, J),
	L=suspension(M, N, O, P, Q, R, S),
	N=mutable(active), !,
	A=S.
'get_target_module/1__0'(A, B) :- !,
	A=user.
attached(A, B) :-
	'attached/2__0'(A, B, C).
'attached/2__0'(A, B, C) :-
	'chr via_1'(A, D),
	get_attr(D, chr_translate_bootstrap1, E),
	E=v(F, G, H, I, J, K, L),
	F/\32=:=32,
	'chr sbag_member'(M, L),
	M=suspension(N, O, P, Q, R, S, T, U),
	O=mutable(active),
	T==A,
	U==yes, !,
	(   var(C)
	->  true
	;   'chr remove_constraint_internal'(C, V),
	    'detach_attached/2'(V, C)
	).
'attached/2__0'(A, B, C) :-
	B==yes,
	'chr via_1'(A, D),
	get_attr(D, chr_translate_bootstrap1, E),
	E=v(F, G, H, I, J, K, L),
	F/\32=:=32, !,
	(   var(C)
	->  'chr allocate_constraint'(chr_translate_bootstrap1:'attached/2__0'(A, B, C), C, attached, [A, B])
	;   true
	),
	'attached/2__0__0'(L, A, B, C).
'attached/2__0__0'([], A, B, C) :-
	'attached/2__1'(A, B, C).
'attached/2__0__0'([A|B], C, D, E) :-
	(   A=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==C
	->  'chr remove_constraint_internal'(A, N),
	    'detach_attached/2'(N, A),
	    'attached/2__0__0'(B, C, D, E)
	;   'attached/2__0__0'(B, C, D, E)
	).
'attached/2__0'(A, B, C) :-
	(   var(C)
	->  'chr allocate_constraint'(chr_translate_bootstrap1:'attached/2__0'(A, B, C), C, attached, [A, B])
	;   true
	),
	'attached/2__1'(A, B, C).
'attached/2__1'(A, B, C) :-
	'chr via_1'(A, D),
	get_attr(D, chr_translate_bootstrap1, E),
	E=v(F, G, H, I, J, K, L),
	F/\32=:=32,
	'chr sbag_member'(M, L),
	M=suspension(N, O, P, Q, R, S, T, U),
	O=mutable(active),
	T==A,
	U==no, !,
	(   var(C)
	->  true
	;   'chr remove_constraint_internal'(C, V),
	    'detach_attached/2'(V, C)
	).
'attached/2__1'(A, B, C) :-
	B==no,
	'chr via_1'(A, D),
	get_attr(D, chr_translate_bootstrap1, E),
	E=v(F, G, H, I, J, K, L),
	F/\32=:=32, !,
	'attached/2__1__0'(L, A, B, C).
'attached/2__1__0'([], A, B, C) :-
	'attached/2__2'(A, B, C).
'attached/2__1__0'([A|B], C, D, E) :-
	(   A=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==C
	->  'chr remove_constraint_internal'(A, N),
	    'detach_attached/2'(N, A),
	    'attached/2__1__0'(B, C, D, E)
	;   'attached/2__1__0'(B, C, D, E)
	).
'attached/2__1'(A, B, C) :-
	'attached/2__2'(A, B, C).
'attached/2__2'(A, B, C) :-
	B==maybe,
	'chr via_1'(A, D),
	get_attr(D, chr_translate_bootstrap1, E),
	E=v(F, G, H, I, J, K, L),
	F/\32=:=32,
	(   'chr sbag_member'(M, L),
	    M=suspension(N, O, P, Q, R, S, T, U),
	    O=mutable(active),
	    T==A,
	    U==maybe
	->  true
	), !,
	(   var(C)
	->  true
	;   'chr remove_constraint_internal'(C, V),
	    'detach_attached/2'(V, C)
	).
'attached/2__2'(A, B, C) :-
	'chr activate_constraint'(D, C, E),
	'attach_attached/2'(D, C).
is_attached(A) :-
	'is_attached/1__0'(A, B).
'is_attached/1__0'(A, B) :-
	'chr via_1'(A, C),
	get_attr(C, chr_translate_bootstrap1, D),
	D=v(E, F, G, H, I, J, K),
	E/\32=:=32,
	'chr sbag_member'(L, K),
	L=suspension(M, N, O, P, Q, R, S, T),
	N=mutable(active),
	S==A, !,
	(   T==no
	->  fail
	;   true
	).
'is_attached/1__0'(A, B) :- !.
chr_clear :-
	'chr_clear/0__0'(A).
'chr_clear/0__0'(A) :-
	'chr global_term_ref_1'(B),
	get_attr(B, chr_translate_bootstrap1, C),
	C=v(D, E, F, G, H, I, J),
	D/\1=:=1, !,
	(   var(A)
	->  'chr allocate_constraint'(chr_translate_bootstrap1:'chr_clear/0__0'(A), A, chr_clear, [])
	;   true
	),
	'chr_clear/0__0__0'(E, A).
'chr_clear/0__0__0'([], A) :-
	'chr_clear/0__1'(A).
'chr_clear/0__0__0'([A|B], C) :-
	(   A=suspension(D, E, F, G, H, I, J, K),
	    E=mutable(active)
	->  'chr remove_constraint_internal'(A, L),
	    'detach_constraint/2'(L, A),
	    'chr_clear/0__0__0'(B, C)
	;   'chr_clear/0__0__0'(B, C)
	).
'chr_clear/0__0'(A) :-
	(   var(A)
	->  'chr allocate_constraint'(chr_translate_bootstrap1:'chr_clear/0__0'(A), A, chr_clear, [])
	;   true
	),
	'chr_clear/0__1'(A).
'chr_clear/0__1'(A) :-
	'chr global_term_ref_1'(B),
	get_attr(B, chr_translate_bootstrap1, C),
	C=v(D, E, F, G, H, I, J),
	D/\2=:=2, !,
	'chr_clear/0__1__0'(F, A).
'chr_clear/0__1__0'([], A) :-
	'chr_clear/0__2'(A).
'chr_clear/0__1__0'([A|B], C) :-
	(   A=suspension(D, E, F, G, H, I, J),
	    E=mutable(active)
	->  'chr remove_constraint_internal'(A, K),
	    'detach_constraint_count/1'(K, A),
	    'chr_clear/0__1__0'(B, C)
	;   'chr_clear/0__1__0'(B, C)
	).
'chr_clear/0__1'(A) :-
	'chr_clear/0__2'(A).
'chr_clear/0__2'(A) :-
	'chr global_term_ref_1'(B),
	get_attr(B, chr_translate_bootstrap1, C),
	C=v(D, E, F, G, H, I, J),
	D/\4=:=4, !,
	'chr_clear/0__2__0'(G, A).
'chr_clear/0__2__0'([], A) :-
	'chr_clear/0__3'(A).
'chr_clear/0__2__0'([A|B], C) :-
	(   A=suspension(D, E, F, G, H, I, J, K),
	    E=mutable(active)
	->  'chr remove_constraint_internal'(A, L),
	    'detach_constraint_index/2'(L, A),
	    'chr_clear/0__2__0'(B, C)
	;   'chr_clear/0__2__0'(B, C)
	).
'chr_clear/0__2'(A) :-
	'chr_clear/0__3'(A).
'chr_clear/0__3'(A) :-
	'chr global_term_ref_1'(B),
	get_attr(B, chr_translate_bootstrap1, C),
	C=v(D, E, F, G, H, I, J),
	D/\8=:=8, !,
	'chr_clear/0__3__0'(H, A).
'chr_clear/0__3__0'([], A) :-
	'chr_clear/0__4'(A).
'chr_clear/0__3__0'([A|B], C) :-
	(   A=suspension(D, E, F, G, H, I, J),
	    E=mutable(active)
	->  'chr remove_constraint_internal'(A, K),
	    'detach_max_constraint_index/1'(K, A),
	    'chr_clear/0__3__0'(B, C)
	;   'chr_clear/0__3__0'(B, C)
	).
'chr_clear/0__3'(A) :-
	'chr_clear/0__4'(A).
'chr_clear/0__4'(A) :-
	'chr global_term_ref_1'(B),
	get_attr(B, chr_translate_bootstrap1, C),
	C=v(D, E, F, G, H, I, J),
	D/\16=:=16, !,
	'chr_clear/0__4__0'(I, A).
'chr_clear/0__4__0'([], A) :-
	'chr_clear/0__5'(A).
'chr_clear/0__4__0'([A|B], C) :-
	(   A=suspension(D, E, F, G, H, I, J),
	    E=mutable(active)
	->  'chr remove_constraint_internal'(A, K),
	    'detach_target_module/1'(K, A),
	    'chr_clear/0__4__0'(B, C)
	;   'chr_clear/0__4__0'(B, C)
	).
'chr_clear/0__4'(A) :-
	'chr_clear/0__5'(A).
'chr_clear/0__5'(A) :-
	'chr global_term_ref_1'(B),
	get_attr(B, chr_translate_bootstrap1, C),
	C=v(D, E, F, G, H, I, J),
	D/\32=:=32, !,
	'chr_clear/0__5__0'(J, A).
'chr_clear/0__5__0'([], A) :-
	'chr_clear/0__6'(A).
'chr_clear/0__5__0'([A|B], C) :-
	(   A=suspension(D, E, F, G, H, I, J, K),
	    E=mutable(active)
	->  'chr remove_constraint_internal'(A, L),
	    'detach_attached/2'(L, A),
	    'chr_clear/0__5__0'(B, C)
	;   'chr_clear/0__5__0'(B, C)
	).
'chr_clear/0__5'(A) :-
	'chr_clear/0__6'(A).
'chr_clear/0__6'(A) :- !.
