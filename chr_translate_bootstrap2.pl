/*  Generated by CHR bootstrap compiler
    From: chr_translate_bootstrap2.chr
    Date: Wed Jan 19 10:16:37 2005

    DO NOT EDIT.  EDIT THE CHR FILE INSTEAD
*/

:-module(chr_translate, [chr_translate/2]).
:-use_module(chr_runtime).
:-style_check(-singleton).
:-style_check(- (discontiguous)).
:-use_module(chr_runtime).
:-use_module(chr_hashtable_store).
:-style_check(-singleton).
:-style_check(- (discontiguous)).
:-use_module(library(lists)).
:-use_module(hprolog).
:-use_module(library(assoc)).
:-use_module(pairlist).
:-use_module(library(ordsets)).
:-use_module(a_star).
:-use_module(clean_code).
:-use_module(builtins).
:-use_module(find).
:-include(chr_op2).
chr_translate(A, B) :-
	init_chr_pp_flags,
	partition_clauses(A, C, D, E),
	(   C==[]
	->  insert_declarations(E, B)
	;   add_rules(D),
	    check_rules(D, C),
	    add_occurrences(D),
	    late_allocation(C),
	    unique_analyse_optimise(D, F),
	    check_attachments(C),
	    assume_constraint_stores(C),
	    set_constraint_indices(C, 1),
	    constraints_code(C, F, G),
	    validate_store_type_assumptions(C),
	    store_management_preds(C, H),
	    insert_declarations(E, I),
	    chr_module_declaration(J),
	    append_lists([I, H, G, J], B)
	).
store_management_preds(A, B) :-
	generate_attach_detach_a_constraint_all(A, C),
	generate_indexed_variables_clauses(A, D),
	generate_attach_increment(E),
	generate_attr_unify_hook(F),
	generate_extra_clauses(A, G),
	generate_insert_delete_constraints(A, H),
	generate_store_code(A, I),
	append_lists([C, D, E, F, G, H, I], B).
insert_declarations(A, B) :-
	(   A=[ (:-module(C, D))|E]
	->  B=[ (:-module(C, D)), (:-use_module(chr_runtime)), (:-use_module(chr_hashtable_store)), (:-style_check(-singleton)), (:-style_check(- (discontiguous)))|E]
	;   B=[ (:-use_module(chr_runtime)), (:-use_module(chr_hashtable_store)), (:-style_check(-singleton)), (:-style_check(- (discontiguous)))|A]
	).
chr_module_declaration(A) :-
	get_target_module(B),
	(   B\==chr_translate
	->  A=[ (:-multifile chr:'$chr_module'/1), chr:'$chr_module'(B)]
	;   A=[]
	).
partition_clauses([], [], [], []).
partition_clauses([A|B], C, D, E) :-
	(   parse_rule(A, F)
	->  C=G,
	    D=[F|H],
	    E=I
	;   is_declaration(A, J)
	->  append(J, G, C),
	    D=H,
	    E=I
	;   is_module_declaration(A, K)
	->  target_module(K),
	    C=G,
	    D=H,
	    E=[A|I]
	;   A=handler(L)
	->  format('CHR compiler WARNING: ~w.\n', [A]),
	    format('    `-->  SICStus compatibility: ignoring handler/1 declaration.\n', []),
	    C=G,
	    D=H,
	    E=I
	;   A=rules(M)
	->  format('CHR compiler WARNING: ~w.\n', [A]),
	    format('    `-->  SICStus compatibility: ignoring rules/1 declaration.\n', []),
	    C=G,
	    D=H,
	    E=I
	;   A=option(N, O)
	->  handle_option(N, O),
	    C=G,
	    D=H,
	    E=I
	;   C=G,
	    D=H,
	    E=[A|I]
	),
	partition_clauses(B, G, H, I).
is_declaration(A, B) :-
	(   A= (:-C)
	->  true
	;   A=C
	),
	C=..[constraints, D],
	conj2list(D, B).
parse_rule(A, B) :-
	A= @(C, D), !,
	rule(D, yes(C), B).
parse_rule(A, B) :-
	rule(A, no, B).
rule(A, B, C) :-
	A=pragma(D, E), !,
	is_rule(D, F, G),
	conj2list(E, H),
	inc_rule_count(I),
	C=pragma(F, G, H, B, I).
rule(A, B, C) :-
	is_rule(A, D, E),
	inc_rule_count(F),
	C=pragma(D, E, [], B, F).
is_rule(A, B, C) :-
	A= ==>(D, E), !,
	conj2list(D, F),
	get_ids(F, G, H),
	C=ids([], G),
	(   E= (I|J)
	->  B=rule([], H, I, J)
	;   B=rule([], H, true, E)
	).
is_rule(A, B, C) :-
	A= <=>(D, E), !,
	(   E= (F|G)
	->  H=F,
	    I=G
	;   H=true,
	    I=E
	),
	(   D= \(J, K)
	->  conj2list(J, L),
	    conj2list(K, M),
	    get_ids(L, N, O, 0, P),
	    get_ids(M, Q, R, P, S),
	    C=ids(Q, N)
	;   conj2list(D, M),
	    O=[],
	    get_ids(M, Q, R),
	    C=ids(Q, [])
	),
	B=rule(R, O, H, I).
get_ids(A, B, C) :-
	get_ids(A, B, C, 0, D).
get_ids([], [], [], A, A).
get_ids([A|B], [C|D], [E|F], C, G) :-
	(   A= #(E, C)
	->  true
	;   E=A
	),
	H is C+1,
	get_ids(B, D, F, H, G).
is_module_declaration((:-module(A)), A).
is_module_declaration((:-module(A, B)), A).
add_rules([]).
add_rules([A|B]) :-
	A=pragma(C, D, E, F, G),
	rule(G, A),
	add_rules(B).
check_rules([], A).
check_rules([A|B], C) :-
	check_rule(A, C),
	check_rules(B, C).
check_rule(A, B) :-
	check_rule_indexing(A),
	A=pragma(C, D, E, F, G),
	C=rule(H, I, J, K),
	append(H, I, L),
	check_head_constraints(L, B, A),
	check_pragmas(E, A).
check_head_constraints([], A, B).
check_head_constraints([A|B], C, D) :-
	functor(A, E, F),
	(   member(E/F, C)
	->  check_head_constraints(B, C, D)
	;   format('CHR compiler ERROR: Undeclared constraint ~w in head of ~@.\n', [E/F, format_rule(D)]),
	    format('    `--> Constraint should be one of ~w.\n', [C]),
	    fail
	).
check_pragmas([], A).
check_pragmas([A|B], C) :-
	check_pragma(A, C),
	check_pragmas(B, C).
check_pragma(A, B) :-
	var(A), !,
	format('CHR compiler ERROR: invalid pragma ~w in ~@.\n', [A, format_rule(B)]),
	format('    `--> Pragma should not be a variable!\n', []),
	fail.
check_pragma(passive(A), B) :- !,
	B=pragma(C, ids(D, E), F, G, H),
	(   memberchk_eq(A, D)
	->  true
	;   memberchk_eq(A, E)
	->  true
	;   format('CHR compiler ERROR: invalid identifier ~w in pragma passive in ~@.\n', [A, format_rule(B)]),
	    fail
	),
	passive(H, A).
check_pragma(A, B) :-
	A=unique(C, D), !,
	B=pragma(E, F, G, H, I),
	pragma_unique(I, C, D),
	format('CHR compiler WARNING: undocument pragma ~w in ~@.\n', [A, format_rule(B)]),
	format('    `--> Only use this pragma if you know what you are doing.\n', []).
check_pragma(A, B) :-
	A=already_in_heads, !,
	format('CHR compiler WARNING: currently unsupported pragma ~w in ~@.\n', [A, format_rule(B)]),
	format('    `--> Pragma is ignored. Termination and correctness may be affected \n', []).
check_pragma(A, B) :-
	A=already_in_head(C), !,
	format('CHR compiler WARNING: currently unsupported pragma ~w in ~@.\n', [A, format_rule(B)]),
	format('    `--> Pragma is ignored. Termination and correctness may be affected \n', []).
check_pragma(A, B) :-
	format('CHR compiler ERROR: invalid pragma ~w in ~@.\n', [A, format_rule(B)]),
	format('    `--> Pragma should be one of passive/1!\n', []),
	fail.
format_rule(A) :-
	A=pragma(B, C, D, E, F),
	(   E=yes(G)
	->  write('rule '),
	    write(G)
	;   write('rule number '),
	    write(F)
	).
check_rule_indexing(A) :-
	A=pragma(B, C, D, E, F),
	B=rule(G, H, I, J),
	term_variables(G-H, K),
	remove_anti_monotonic_guards(I, K, L),
	check_indexing(G, L-H),
	check_indexing(H, L-G).
remove_anti_monotonic_guards(A, B, C) :-
	conj2list(A, D),
	remove_anti_monotonic_guard_list(D, B, E),
	list2conj(E, C).
remove_anti_monotonic_guard_list([], A, []).
remove_anti_monotonic_guard_list([A|B], C, D) :-
	(   A=var(E),
	    memberchk_eq(E, C)
	->  D=F
	;   D=[A|F]
	),
	remove_anti_monotonic_guard_list(B, C, F).
check_indexing([], A).
check_indexing([A|B], C) :-
	functor(A, D, E),
	A=..[F|G],
	term_variables(B-C, H),
	check_indexing(G, 1, D/E, H),
	check_indexing(B, [A|C]).
check_indexing([], A, B, C).
check_indexing([A|B], C, D, E) :-
	(   is_indexed_argument(D, C)
	->  true
	;   nonvar(A)
	->  indexed_argument(D, C)
	;   term_variables(B, F),
	    append(F, E, G),
	    (   memberchk_eq(A, G)
	    ->  indexed_argument(D, C)
	    ;   true
	    )
	),
	H is C+1,
	term_variables(A, I),
	append(I, E, J),
	check_indexing(B, H, D, J).
add_occurrences([]).
add_occurrences([A|B]) :-
	A=pragma(rule(C, D, E, F), ids(G, H), I, J, K),
	add_occurrences(C, G, K),
	add_occurrences(D, H, K),
	add_occurrences(B).
add_occurrences([], [], A).
add_occurrences([A|B], [C|D], E) :-
	functor(A, F, G),
	H=F/G,
	get_max_occurrence(H, I),
	J is I+1,
	occurrence(H, J, E, C),
	add_occurrences(B, D, E).
late_allocation([]).
late_allocation([A|B]) :-
	allocation_occurrence(A, 1),
	late_allocation(B).
handle_option(A, B) :-
	var(A), !,
	format('CHR compiler ERROR: ~w.\n', [option(A, B)]),
	format('    `--> First argument should be an atom, not a variable.\n', []),
	fail.
handle_option(A, B) :-
	var(B), !,
	format('CHR compiler ERROR: ~w.\n', [option(A, B)]),
	format('    `--> Second argument should be a nonvariable.\n', []),
	fail.
handle_option(A, B) :-
	option_definition(A, B, C), !,
	set_chr_pp_flags(C).
handle_option(A, B) :-
	\+option_definition(A, C, D), !,
	format('CHR compiler WARNING: ~w.\n', [option(A, B)]),
	format('    `--> Invalid option name \n', []).
handle_option(A, B) :-
	findall(C, option_definition(A, C, D), E),
	format('CHR compiler ERROR: ~w.\n', [option(A, B)]),
	format('    `--> Invalid value ~w: should be one of ~w.\n', [B, E]),
	fail.
option_definition(optimize, experimental, A) :-
	A=[unique_analyse_optimise-on, check_unnecessary_active-full, reorder_heads-on, set_semantics_rule-on, check_attachments-on, guard_via_reschedule-on].
option_definition(optimize, full, A) :-
	A=[unique_analyse_optimise-on, check_unnecessary_active-full, reorder_heads-on, set_semantics_rule-on, check_attachments-on, guard_via_reschedule-on].
option_definition(optimize, sicstus, A) :-
	A=[unique_analyse_optimise-off, check_unnecessary_active-simplification, reorder_heads-off, set_semantics_rule-off, check_attachments-off, guard_via_reschedule-off].
option_definition(optimize, off, A) :-
	A=[unique_analyse_optimise-off, check_unnecessary_active-off, reorder_heads-off, set_semantics_rule-off, check_attachments-off, guard_via_reschedule-off].
option_definition(check_guard_bindings, on, A) :-
	A=[guard_locks-on].
option_definition(check_guard_bindings, off, A) :-
	A=[guard_locks-off].
option_definition(reduced_indexing, on, A) :-
	A=[reduced_indexing-on].
option_definition(reduced_indexing, off, A) :-
	A=[reduced_indexing-off].
option_definition(mode, A, []) :-
	(   nonvar(A)
	->  functor(A, B, C),
	    A=..[D|E],
	    constraint_mode(B/C, E)
	;   true
	).
option_definition(store, A-B, []) :-
	store_type(A, B).
option_definition(debug, on, A) :-
	A=[debugable-on].
option_definition(debug, off, A) :-
	A=[debugable-off].
init_chr_pp_flags :-
	chr_pp_flag_definition(A, [B|C]),
	set_chr_pp_flag(A, B),
	fail.
init_chr_pp_flags.
set_chr_pp_flags([]).
set_chr_pp_flags([A-B|C]) :-
	set_chr_pp_flag(A, B),
	set_chr_pp_flags(C).
set_chr_pp_flag(A, B) :-
	atom_concat('$chr_pp_', A, C),
	nb_setval(C, B).
chr_pp_flag_definition(unique_analyse_optimise, [on, off]).
chr_pp_flag_definition(check_unnecessary_active, [full, simplification, off]).
chr_pp_flag_definition(reorder_heads, [on, off]).
chr_pp_flag_definition(set_semantics_rule, [on, off]).
chr_pp_flag_definition(guard_via_reschedule, [on, off]).
chr_pp_flag_definition(guard_locks, [on, off]).
chr_pp_flag_definition(check_attachments, [on, off]).
chr_pp_flag_definition(debugable, [off, on]).
chr_pp_flag_definition(reduced_indexing, [on, off]).
chr_pp_flag(A, B) :-
	atom_concat('$chr_pp_', A, C),
	nb_getval(C, D),
	(   D==[]
	->  chr_pp_flag_definition(A, [B|E])
	;   D=B
	).
generate_attach_detach_a_constraint_all([], []).
generate_attach_detach_a_constraint_all([A|B], C) :-
	(   may_trigger(A)
	->  generate_attach_a_constraint(A, D),
	    generate_detach_a_constraint(A, E)
	;   D=[],
	    E=[]
	),
	generate_attach_detach_a_constraint_all(B, F),
	append_lists([D, E, F], C).
generate_attach_a_constraint(A, [B, C]) :-
	generate_attach_a_constraint_empty_list(A, B),
	get_max_constraint_index(D),
	(   D==1
	->  generate_attach_a_constraint_1_1(A, C)
	;   generate_attach_a_constraint_t_p(A, C)
	).
generate_attach_a_constraint_skeleton(A, B, C, D) :-
	make_name(attach_, A, E),
	F=..[E|B],
	D= (F:-C).
generate_attach_a_constraint_empty_list(A, B) :-
	generate_attach_a_constraint_skeleton(A, [[], C], true, B).
generate_attach_a_constraint_1_1(A, B) :-
	C=[[D|E], F],
	generate_attach_a_constraint_skeleton(A, C, G, B),
	generate_attach_body_1(A, D, F, H),
	make_name(attach_, A, I),
	J=..[I, E, F],
	G= (H, J).
generate_attach_body_1(A, B, C, D) :-
	get_target_module(E),
	D= (get_attr(B, E, F)->G=[C|F], put_attr(B, E, G);put_attr(B, E, [C])).
generate_attach_a_constraint_t_p(A, B) :-
	C=[[D|E], F],
	generate_attach_a_constraint_skeleton(A, C, G, B),
	make_name(attach_, A, H),
	I=..[H, E, F],
	generate_attach_body_n(A, D, F, J),
	G= (J, I).
generate_attach_body_n(A/B, C, D, E) :-
	get_constraint_index(A/B, F),
	or_pattern(F, G),
	get_max_constraint_index(H),
	make_attr(H, I, J, K),
	nth(F, J, L),
	substitute(L, J, [D|L], M),
	make_attr(H, I, M, N),
	substitute(L, J, [D], O),
	make_attr(H, P, O, Q),
	copy_term(J, R),
	nth(F, R, [D]),
	delete(R, [D], S),
	set_elems(S, []),
	make_attr(H, G, R, T),
	get_target_module(U),
	E= (get_attr(C, U, V)->V=K, (I/\G=:=G->put_attr(C, U, N);P is I\/G, put_attr(C, U, Q));put_attr(C, U, T)).
generate_detach_a_constraint(A, [B, C]) :-
	generate_detach_a_constraint_empty_list(A, B),
	get_max_constraint_index(D),
	(   D==1
	->  generate_detach_a_constraint_1_1(A, C)
	;   generate_detach_a_constraint_t_p(A, C)
	).
generate_detach_a_constraint_empty_list(A, B) :-
	make_name(detach_, A, C),
	D=[[], E],
	F=..[C|D],
	B= (F:-true).
generate_detach_a_constraint_1_1(A, B) :-
	make_name(detach_, A, C),
	D=[[E|F], G],
	H=..[C|D],
	I=..[C, F, G],
	generate_detach_body_1(A, E, G, J),
	K= (J, I),
	B= (H:-K).
generate_detach_body_1(A, B, C, D) :-
	get_target_module(E),
	D= (get_attr(B, E, F)->'chr sbag_del_element'(F, C, G), (G==[]->del_attr(B, E);put_attr(B, E, G));true).
generate_detach_a_constraint_t_p(A, B) :-
	make_name(detach_, A, C),
	D=[[E|F], G],
	H=..[C|D],
	I=..[C, F, G],
	generate_detach_body_n(A, E, G, J),
	K= (J, I),
	B= (H:-K).
generate_detach_body_n(A/B, C, D, E) :-
	get_constraint_index(A/B, F),
	or_pattern(F, G),
	and_pattern(F, H),
	get_max_constraint_index(I),
	make_attr(I, J, K, L),
	nth(F, K, M),
	substitute(M, K, [], N),
	make_attr(I, O, N, P),
	substitute(M, K, Q, R),
	make_attr(I, J, R, S),
	get_target_module(T),
	E= (get_attr(C, T, U)->U=L, (J/\G=:=G->'chr sbag_del_element'(M, D, Q), (Q==[]->O is J/\H, (O==0->del_attr(C, T);put_attr(C, T, P));put_attr(C, T, S));true);true).
generate_indexed_variables_clauses(A, B) :-
	(   forsome(C, A, chr_translate:may_trigger(C))
	->  generate_indexed_variables_clauses_(A, B)
	;   B=[]
	).
generate_indexed_variables_clauses_([], []).
generate_indexed_variables_clauses_([A|B], C) :-
	(   (   is_attached(A)
	    ;   chr_pp_flag(debugable, on)
	    )
	->  C=[D|E],
	    generate_indexed_variables_clause(A, D)
	;   C=E
	),
	generate_indexed_variables_clauses_(B, E).
generate_indexed_variables_clause(A/B, C) :-
	functor(D, A, B),
	get_constraint_mode(A/B, E),
	D=..[F|G],
	create_indexed_variables_body(G, E, H, 1, A/B, I, J),
	(   I==empty
	->  K= (H=[])
	;   J==0
	->  K=term_variables(L, H)
	;   I=K
	),
	C= ('$indexed_variables'(L, H):-L=D, K).
create_indexed_variables_body([], [], A, B, C, empty, 0).
create_indexed_variables_body([A|B], [C|D], E, F, G, H, I) :-
	J is F+1,
	create_indexed_variables_body(B, D, K, J, G, L, M),
	(   C\== +,
	    is_indexed_argument(G, F)
	->  (   L==empty
	    ->  H=term_variables(A, E)
	    ;   H= (term_variables(A, E, K), L)
	    ),
	    I=M
	;   E=K,
	    H=L,
	    I is M+1
	).
generate_extra_clauses(A, [B, C, D, E, F]) :-
	(   chr_pp_flag(reduced_indexing, on)
	->  global_indexed_variables_clause(A, E)
	;   E= (chr_indexed_variables(G, H):-'chr chr_indexed_variables'(G, H))
	),
	generate_remove_clause(B),
	generate_activate_clause(C),
	generate_allocate_clause(D),
	generate_insert_constraint_internal(F).
generate_remove_clause(A) :-
	A= (remove_constraint_internal(B, C, D):-arg(2, B, E), E=mutable(F), 'chr update_mutable'(removed, E), (compound(F)->C=[], D=no;F==removed->C=[], D=no;D=yes, chr_indexed_variables(B, C))).
generate_activate_clause(A) :-
	A= (activate_constraint(B, C, D, E):-arg(2, D, F), F=mutable(G), 'chr update_mutable'(active, F), (nonvar(E)->true;arg(4, D, H), H=mutable(I), E is I+1, 'chr update_mutable'(E, H)), (compound(G)->term_variables(G, C), 'chr none_locked'(C), B=yes;G==removed->chr_indexed_variables(D, C), B=yes;C=[], B=no)).
generate_allocate_clause(A) :-
	A= (allocate_constraint(B, C, D, E):-C=..[suspension, F, G, B, H, I, D|E], H=mutable(0), 'chr empty_history'(J), I=mutable(J), chr_indexed_variables(C, K), G=mutable(passive(K)), 'chr gen_id'(F)).
generate_insert_constraint_internal(A) :-
	A= (insert_constraint_internal(yes, B, C, D, E, F):-C=..[suspension, G, H, D, I, J, E|F], chr_indexed_variables(C, B), 'chr none_locked'(B), H=mutable(active), I=mutable(0), J=mutable(K), 'chr empty_history'(K), 'chr gen_id'(G)).
global_indexed_variables_clause(A, B) :-
	(   forsome(C, A, chr_translate:may_trigger(C))
	->  D= (E=..[F, G, H, I, J, K, L|M], '$indexed_variables'(L, N))
	;   D=true,
	    N=[]
	),
	B= (chr_indexed_variables(E, N):-D).
generate_attach_increment(A) :-
	get_max_constraint_index(B),
	(   B>0
	->  A=[C, D],
	    generate_attach_increment_empty(C),
	    (   B==1
	    ->  generate_attach_increment_one(D)
	    ;   generate_attach_increment_many(B, D)
	    )
	;   A=[]
	).
generate_attach_increment_empty((attach_increment([], A):-true)).
generate_attach_increment_one(A) :-
	B=attach_increment([C|D], E),
	get_target_module(F),
	G= ('chr not_locked'(C), (get_attr(C, F, H)->sort(H, I), merge(E, I, J), put_attr(C, F, J);put_attr(C, F, E)), attach_increment(D, E)),
	A= (B:-G).
generate_attach_increment_many(A, B) :-
	make_attr(A, C, D, E),
	make_attr(A, F, G, H),
	I=attach_increment([J|K], E),
	bagof(L, M^N^O^P^ (member2(D, G, M-N), L= (sort(N, O), 'chr merge_attributes'(M, O, P))), Q),
	list2conj(Q, R),
	bagof(S, T^U^V^member((T, 'chr merge_attributes'(U, V, S)), Q), W),
	make_attr(A, X, W, Y),
	get_target_module(Z),
	A1= ('chr not_locked'(J), (get_attr(J, Z, B1)->B1=H, R, X is C\/F, put_attr(J, Z, Y);put_attr(J, Z, E)), attach_increment(K, E)),
	B= (I:-A1).
generate_attr_unify_hook([A]) :-
	get_max_constraint_index(B),
	(   B==0
	->  get_target_module(C),
	    A= (attr_unify_hook(D, E):-write('ERROR: Unexpected triggering of attr_unify_hook/2 in module '), writeln(C))
	;   B==1
	->  generate_attr_unify_hook_one(A)
	;   generate_attr_unify_hook_many(B, A)
	).
generate_attr_unify_hook_one(A) :-
	B=attr_unify_hook(C, D),
	get_target_module(E),
	make_run_suspensions(F, G),
	make_run_suspensions(C, H),
	I= (sort(C, J), (var(D)-> (get_attr(D, E, K)->true;K=[]), sort(K, L), 'chr merge_attributes'(J, L, F), put_attr(D, E, F), G; (compound(D)->term_variables(D, M), attach_increment(M, J);true), H)),
	A= (B:-I).
generate_attr_unify_hook_many(A, B) :-
	make_attr(A, C, D, E),
	make_attr(A, F, G, H),
	bagof(I, J^K^ (member(J, D), I=sort(J, K)), L),
	list2conj(L, M),
	bagof(K, J^member(sort(J, K), L), N),
	bagof(O, P^Q^R^S^ (member2(N, G, P-Q), O= (sort(Q, R), 'chr merge_attributes'(P, R, S))), T),
	bagof(S, P^R^U^member((U, 'chr merge_attributes'(P, R, S)), T), V),
	list2conj(T, W),
	make_attr(A, X, V, Y),
	make_attr(A, C, N, Z),
	A1=attr_unify_hook(E, B1),
	get_target_module(C1),
	make_run_suspensions_loop(V, D1),
	make_run_suspensions_loop(N, E1),
	F1= (M, (var(B1)-> (get_attr(B1, C1, G1)->G1=H, W, X is C\/F, put_attr(B1, C1, Y), D1;put_attr(B1, C1, Z), E1); (compound(B1)->term_variables(B1, H1), attach_increment(H1, Z);true), E1)),
	B= (A1:-F1).
make_run_suspensions(A, B) :-
	(   chr_pp_flag(debugable, on)
	->  B='chr run_suspensions_d'(A)
	;   B='chr run_suspensions'(A)
	).
make_run_suspensions_loop(A, B) :-
	(   chr_pp_flag(debugable, on)
	->  B='chr run_suspensions_loop_d'(A)
	;   B='chr run_suspensions_loop'(A)
	).
generate_insert_delete_constraints([], []).
generate_insert_delete_constraints([A|B], C) :-
	(   is_attached(A)
	->  C=[D, E|F],
	    generate_insert_delete_constraint(A, D, E)
	;   C=F
	),
	generate_insert_delete_constraints(B, F).
generate_insert_delete_constraint(A, B, C) :-
	get_store_type(A, D),
	generate_insert_constraint(D, A, B),
	generate_delete_constraint(D, A, C).
generate_insert_constraint(A, B, C) :-
	make_name('$insert_in_store_', B, D),
	E=..[D, F],
	generate_insert_constraint_body(A, B, F, G),
	C= (E:-G).
generate_insert_constraint_body(default, A, B, C) :-
	get_target_module(D),
	get_max_constraint_index(E),
	(   E==1
	->  generate_attach_body_1(A, F, B, G)
	;   generate_attach_body_n(A, F, B, G)
	),
	C= ('chr global_term_ref_1'(F), G).
generate_insert_constraint_body(multi_hash(A), B, C, D) :-
	generate_multi_hash_insert_constraint_bodies(A, B, C, D).
generate_insert_constraint_body(global_ground, A, B, C) :-
	global_ground_store_name(A, D),
	C= (nb_getval(D, E), b_setval(D, [B|E])).
generate_insert_constraint_body(multi_store(A), B, C, D) :-
	find_with_var_identity(E, [C], (member(F, A), chr_translate:generate_insert_constraint_body(F, B, C, E)), G),
	list2conj(G, D).
generate_multi_hash_insert_constraint_bodies([], A, B, true).
generate_multi_hash_insert_constraint_bodies([A|B], C, D, (E, F)) :-
	multi_hash_store_name(C, A, G),
	multi_hash_key(C, A, D, H, I),
	E= (H, nb_getval(G, J), insert_ht(J, I, D)),
	generate_multi_hash_insert_constraint_bodies(B, C, D, F).
generate_delete_constraint(A, B, C) :-
	make_name('$delete_from_store_', B, D),
	E=..[D, F],
	generate_delete_constraint_body(A, B, F, G),
	C= (E:-G).
generate_delete_constraint_body(default, A, B, C) :-
	get_target_module(D),
	get_max_constraint_index(E),
	(   E==1
	->  generate_detach_body_1(A, F, B, G),
	    C= ('chr global_term_ref_1'(F), G)
	;   generate_detach_body_n(A, F, B, G),
	    C= ('chr global_term_ref_1'(F), G)
	).
generate_delete_constraint_body(multi_hash(A), B, C, D) :-
	generate_multi_hash_delete_constraint_bodies(A, B, C, D).
generate_delete_constraint_body(global_ground, A, B, C) :-
	global_ground_store_name(A, D),
	C= (nb_getval(D, E), 'chr sbag_del_element'(E, B, F), b_setval(D, F)).
generate_delete_constraint_body(multi_store(A), B, C, D) :-
	find_with_var_identity(E, [C], (member(F, A), chr_translate:generate_delete_constraint_body(F, B, C, E)), G),
	list2conj(G, D).
generate_multi_hash_delete_constraint_bodies([], A, B, true).
generate_multi_hash_delete_constraint_bodies([A|B], C, D, (E, F)) :-
	multi_hash_store_name(C, A, G),
	multi_hash_key(C, A, D, H, I),
	E= (H, nb_getval(G, J), delete_ht(J, I, D)),
	generate_multi_hash_delete_constraint_bodies(B, C, D, F).
generate_delete_constraint_call(A, B, C) :-
	make_name('$delete_from_store_', A, D),
	C=..[D, B].
generate_insert_constraint_call(A, B, C) :-
	make_name('$insert_in_store_', A, D),
	C=..[D, B].
generate_store_code(A, [B|C]) :-
	enumerate_stores_code(A, B),
	generate_store_code(A, C, []).
generate_store_code([], A, A).
generate_store_code([A|B], C, D) :-
	get_store_type(A, E),
	generate_store_code(E, A, C, F),
	generate_store_code(B, F, D).
generate_store_code(default, A, B, B).
generate_store_code(multi_hash(A), B, C, D) :-
	multi_hash_store_initialisations(A, B, C, E),
	multi_hash_via_lookups(A, B, E, D).
generate_store_code(global_ground, A, B, C) :-
	global_ground_store_initialisation(A, B, C).
generate_store_code(multi_store(A), B, C, D) :-
	multi_store_generate_store_code(A, B, C, D).
multi_store_generate_store_code([], A, B, B).
multi_store_generate_store_code([A|B], C, D, E) :-
	generate_store_code(A, C, D, F),
	multi_store_generate_store_code(B, C, F, E).
multi_hash_store_initialisations([], A, B, B).
multi_hash_store_initialisations([A|B], C, D, E) :-
	multi_hash_store_name(C, A, F),
	D=[ (:-new_ht(G), nb_setval(F, G))|H],
	multi_hash_store_initialisations(B, C, H, E).
global_ground_store_initialisation(A, B, C) :-
	global_ground_store_name(A, D),
	B=[ (:-nb_setval(D, []))|C].
multi_hash_via_lookups([], A, B, B).
multi_hash_via_lookups([A|B], C, D, E) :-
	multi_hash_via_lookup_name(C, A, F),
	G=..[F, H, I],
	multi_hash_store_name(C, A, J),
	K= (nb_getval(J, L), lookup_ht(L, H, I)),
	D=[ (G:-K)|M],
	multi_hash_via_lookups(B, C, M, E).
multi_hash_via_lookup_name(A/B, C, D) :-
	(   integer(C)
	->  E=C
	;   is_list(C)
	->  atom_concat_list(C, E)
	),
	atom_concat_list(['$via1_multi_hash_', A, /, B, -, E], D).
multi_hash_store_name(A/B, C, D) :-
	get_target_module(E),
	(   integer(C)
	->  F=C
	;   is_list(C)
	->  atom_concat_list(C, F)
	),
	atom_concat_list(['$chr_store_multi_hash_', E, :, A, /, B, -, F], D).
multi_hash_key(A/B, C, D, E, F) :-
	(   (   integer(C)
	    ->  G=C
	    ;   C=[G]
	    )
	->  H is G+6,
	    E=arg(H, D, F)
	;   is_list(C)
	->  sort(C, I),
	    find_with_var_identity(arg(J, D, K)-K, [D], (member(G, I), J is G+6), L),
	    pairup(M, N, L),
	    F=..[k|N],
	    list2conj(M, E)
	).
multi_hash_key_args(A, B, C) :-
	(   integer(A)
	->  arg(A, B, D),
	    C=[D]
	;   is_list(A)
	->  sort(A, E),
	    term_variables(B, F),
	    find_with_var_identity(D, F, (member(G, E), arg(G, B, D)), C)
	).
global_ground_store_name(A/B, C) :-
	get_target_module(D),
	atom_concat_list(['$chr_store_global_ground_', D, :, A, /, B], C).
enumerate_stores_code(A, B) :-
	C='$enumerate_suspensions'(D),
	enumerate_store_bodies(A, D, E),
	list2disj(E, F),
	B= (C:-F).
enumerate_store_bodies([], A, []).
enumerate_store_bodies([A|B], C, D) :-
	(   is_attached(A)
	->  get_store_type(A, E),
	    enumerate_store_body(E, A, C, F),
	    D=[F|G]
	;   D=G
	),
	enumerate_store_bodies(B, C, G).
enumerate_store_body(default, A, B, C) :-
	get_constraint_index(A, D),
	get_target_module(E),
	get_max_constraint_index(F),
	G= ('chr global_term_ref_1'(H), get_attr(H, E, I)),
	(   F>1
	->  J is D+1,
	    K= (arg(J, I, L), 'chr sbag_member'(B, L))
	;   K='chr sbag_member'(B, I)
	),
	C= (G, K).
enumerate_store_body(multi_hash([A|B]), C, D, E) :-
	multi_hash_enumerate_store_body(A, C, D, E).
enumerate_store_body(global_ground, A, B, C) :-
	global_ground_store_name(A, D),
	C= (nb_getval(D, E), 'chr sbag_member'(B, E)).
enumerate_store_body(multi_store(A), B, C, D) :-
	once((
	    member(E, A),
	    enumerate_store_body(E, B, C, D)
	    )).
multi_hash_enumerate_store_body(A, B, C, D) :-
	multi_hash_store_name(B, A, E),
	D= (nb_getval(E, F), value_ht(F, C)).
check_attachments(A) :-
	(   chr_pp_flag(check_attachments, on)
	->  check_constraint_attachments(A)
	;   true
	).
check_constraint_attachments([]).
check_constraint_attachments([A|B]) :-
	check_constraint_attachment(A),
	check_constraint_attachments(B).
check_constraint_attachment(A) :-
	get_max_occurrence(A, B),
	check_occurrences_attachment(A, 1, B).
check_occurrences_attachment(A, B, C) :-
	(   B>C
	->  true
	;   check_occurrence_attachment(A, B),
	    D is B+1,
	    check_occurrences_attachment(A, D, C)
	).
check_occurrence_attachment(A, B) :-
	get_occurrence(A, B, C, D),
	get_rule(C, E),
	E=pragma(rule(F, G, H, I), ids(J, K), L, M, N),
	(   select2(D, O, J, F, P, Q)
	->  check_attachment_head1(O, D, C, F, G, H)
	;   select2(D, R, K, G, S, T)
	->  check_attachment_head2(R, D, C, F, I)
	).
check_attachment_head1(A, B, C, D, E, F) :-
	functor(A, G, H),
	(   D==[A],
	    E==[],
	    F==true,
	    A=..[I|J],
	    no_matching(J, []),
	    \+is_passive(C, B)
	->  attached(G/H, no)
	;   attached(G/H, maybe)
	).
no_matching([], A).
no_matching([A|B], C) :-
	var(A),
	\+memberchk_eq(A, C),
	no_matching(B, [A|C]).
check_attachment_head2(A, B, C, D, E) :-
	functor(A, F, G),
	(   is_passive(C, B)
	->  attached(F/G, maybe)
	;   D\==[],
	    E==true
	->  attached(F/G, maybe)
	;   attached(F/G, yes)
	).
all_attached([]).
all_attached([A|B]) :-
	functor(A, C, D),
	is_attached(C/D),
	all_attached(B).
set_constraint_indices([], A) :-
	B is A-1,
	max_constraint_index(B).
set_constraint_indices([A|B], C) :-
	(   (   may_trigger(A)
	    ;   is_attached(A),
		get_store_type(A, default)
	    )
	->  constraint_index(A, C),
	    D is C+1,
	    set_constraint_indices(B, D)
	;   set_constraint_indices(B, C)
	).
constraints_code(A, B, C) :-
	post_constraints(A, 1),
	constraints_code1(1, B, D, []),
	clean_clauses(D, C).
post_constraints([], A) :-
	B is A-1,
	constraint_count(B).
post_constraints([A/B|C], D) :-
	constraint(A/B, D),
	E is D+1,
	post_constraints(C, E).
constraints_code1(A, B, C, D) :-
	get_constraint_count(E),
	(   A>E
	->  D=C
	;   constraint_code(A, B, C, F),
	    G is A+1,
	    constraints_code1(G, B, F, D)
	).
constraint_code(A, B, C, D) :-
	get_constraint(E, A),
	constraint_prelude(E, F),
	C=[F|G],
	H=[0],
	rules_code(B, A, H, I, G, J),
	gen_cond_attach_clause(E, I, J, D).
constraint_prelude(A/B, C) :-
	vars_susp(B, D, E, F),
	G=..[A|D],
	build_head(A, B, [0], F, H),
	get_target_module(I),
	J=..[A|D],
	(   chr_pp_flag(debugable, on)
	->  C= (G:-allocate_constraint(I:H, E, J, D), ('chr debug_event'(call(E)), H;'chr debug_event'(fail(E)), !, fail), ('chr debug_event'(exit(E));'chr debug_event'(redo(E)), fail))
	;   C= (G:-H)
	).
gen_cond_attach_clause(A/B, C, D, E) :-
	(   is_attached(A/B)
	->  (   C==[0]
	    ->  (   may_trigger(A/B)
		->  gen_cond_attach_goal(A/B, F, G, H, I)
		;   gen_insert_constraint_internal_goal(A/B, F, G, H, I)
		)
	    ;   vars_susp(B, H, I, G),
		gen_uncond_attach_goal(A/B, I, F, J)
	    ),
	    (   chr_pp_flag(debugable, on)
	    ->  K=..[A|H],
		L='chr debug_event'(insert(#(K, I)))
	    ;   L=true
	    ),
	    build_head(A, B, C, G, M),
	    N= (M:-L, F),
	    D=[N|E]
	;   D=E
	).
gen_cond_attach_goal(A/B, C, D, E, F) :-
	vars_susp(B, E, F, D),
	build_head(A, B, [0], D, G),
	(   may_trigger(A/B)
	->  make_name(attach_, A/B, H),
	    I=..[H, J, F]
	;   I=true
	),
	get_target_module(K),
	L=..[A|E],
	generate_insert_constraint_call(A/B, F, M),
	C= ((var(F)->insert_constraint_internal(N, J, F, K:G, L, E);activate_constraint(N, J, F, O)), (N==yes->M, I;true)).
gen_insert_constraint_internal_goal(A/B, C, D, E, F) :-
	vars_susp(B, E, F, D),
	build_head(A, B, [0], D, G),
	(   may_trigger(A/B)
	->  make_name(attach_, A/B, H),
	    I=..[H, J, F]
	;   I=true
	),
	get_target_module(K),
	L=..[A|E],
	generate_insert_constraint_call(A/B, F, M),
	C= (insert_constraint_internal(N, J, F, K:G, L, E), M, I).
gen_uncond_attach_goal(A, B, C, D) :-
	(   may_trigger(A)
	->  make_name(attach_, A, E),
	    F=..[E, G, B]
	;   F=true
	),
	generate_insert_constraint_call(A, B, H),
	C= (activate_constraint(I, G, B, D), (I==yes->H, F;true)).
occurrences_code(A, B, C, D, E, F, G) :-
	(   A>B
	->  E=D,
	    F=G
	;   occurrence_code(A, C, D, H, F, I),
	    J is A+1,
	    occurrences_code(J, B, C, H, E, I, G)
	).
occurrences_code(A, B, C, D, E, F) :-
	get_occurrence(B, A, G, H),
	(   is_passive(G, H)
	->  D=C,
	    E=F
	;   get_rule(G, I),
	    I=pragma(rule(J, K, L, M), ids(N, O), P, Q, R),
	    (   select2(N, J, H, S, T, U)
	    ->  D=C,
		head1_code(S, U, T, I, B, C, E, F)
	    ;   select2(O, K, H, V, W, X)
	    ->  length(X, Y),
		head2_code(V, X, W, I, Y, B, C, E, Z),
		inc_id(C, D),
		gen_alloc_inc_clause(B, C, Z, F)
	    )
	).
rules_code([], A, B, B, C, C).
rules_code([A|B], C, D, E, F, G) :-
	rule_code(A, C, D, H, F, I),
	rules_code(B, C, H, E, I, G).
rule_code(A, B, C, D, E, F) :-
	A=pragma(G, H, I, J, K),
	H=ids(L, M),
	G=rule(N, O, P, Q),
	heads1_code(N, [], L, [], A, B, C, E, R),
	heads2_code(O, [], M, [], A, B, C, D, R, F).
heads1_code([], A, B, C, D, E, F, G, G).
heads1_code([A|B], C, [D|E], F, G, H, I, J, K) :-
	G=pragma(L, M, N, O, P),
	get_constraint(Q/R, H),
	(   functor(A, Q, R),
	    \+is_passive(P, D),
	    \+check_unnecessary_active(A, C, L),
	    all_attached(B),
	    all_attached(C),
	    L=rule(S, T, U, V),
	    all_attached(T)
	->  append(B, C, W),
	    append(E, F, X),
	    head1_code(A, W, X, G, Q/R, H, I, J, Y)
	;   J=Y
	),
	heads1_code(B, [A|C], E, [D|F], G, H, I, Y, K).
head1_code(A, B, C, D, E, F, G, H, I) :-
	D=pragma(J, K, L, M, N),
	J=rule(O, P, Q, R),
	(   P==[]
	->  reorder_heads(N, A, B, C, S, T),
	    simplification_code(A, S, T, D, E, G, H, I)
	;   simpagation_head1_code(A, B, C, D, E, G, H, I)
	).
heads2_code([], A, B, C, D, E, F, F, G, G).
heads2_code([A|B], C, [D|E], F, G, H, I, J, K, L) :-
	G=pragma(M, N, O, P, Q),
	get_constraint(R/S, H),
	(   functor(A, R, S),
	    \+is_passive(Q, D),
	    \+check_unnecessary_active(A, C, M),
	    \+set_semantics_rule(G),
	    all_attached(B),
	    all_attached(C),
	    M=rule(T, U, V, W),
	    all_attached(T)
	->  append(B, C, X),
	    append(E, F, Y),
	    length(B, Z),
	    head2_code(A, X, Y, G, Z, R/S, I, K, A1),
	    inc_id(I, B1),
	    gen_alloc_inc_clause(R/S, I, A1, C1)
	;   K=C1,
	    B1=I
	),
	heads2_code(B, [A|C], E, [D|F], G, H, B1, J, C1, L).
head2_code(A, B, C, D, E, F, G, H, I) :-
	D=pragma(J, K, L, M, N),
	J=rule(O, P, Q, R),
	(   O==[]
	->  reorder_heads(N, A, B, C, S, T),
	    propagation_code(A, S, J, N, E, F, G, H, I)
	;   simpagation_head2_code(A, B, C, D, F, G, H, I)
	).
gen_alloc_inc_clause(A/B, C, D, E) :-
	vars_susp(B, F, G, H),
	build_head(A, B, C, H, I),
	inc_id(C, J),
	build_head(A, B, J, H, K),
	gen_allocation(C, F, G, A/B, H, L),
	M= (I:-L, K),
	D=[M|E].
gen_cond_allocation(A, B, C, D, E) :-
	gen_allocation(A, B, C, D, F),
	E= (var(B)->F;true).
gen_allocation(A, B, C/D, E, F) :-
	build_head(C, D, [0], E, G),
	get_target_module(H),
	I=..[C|A],
	F=allocate_constraint(H:G, B, I, A).
gen_allocation(A, B, C, D, E, F) :-
	(   A==[0]
	->  (   is_attached(D)
	    ->  (   may_trigger(D)
		->  gen_cond_allocation(B, C, D, E, F)
		;   gen_allocation(B, C, D, E, F)
		)
	    ;   F=true
	    )
	;   F=true
	).
guard_via_reschedule(A, B, C, D) :-
	(   chr_pp_flag(guard_via_reschedule, on)
	->  guard_via_reschedule_main(A, B, C, D)
	;   append(A, B, E),
	    list2conj(E, D)
	).
guard_via_reschedule_main(A, B, C, D) :-
	initialize_unit_dictionary(C, E),
	build_units(A, B, E, F),
	dependency_reorder(F, G),
	units2goal(G, D).
units2goal([], true).
units2goal([unit(A, B, C, D)|E], (B, F)) :-
	units2goal(E, F).
dependency_reorder(A, B) :-
	dependency_reorder(A, [], B).
dependency_reorder([], A, B) :-
	reverse(A, B).
dependency_reorder([A|B], C, D) :-
	A=unit(E, F, G, H),
	(   G==fixed
	->  I=[A|C]
	;   dependency_insert(C, A, H, I)
	),
	dependency_reorder(B, I, D).
dependency_insert([], A, B, [A]).
dependency_insert([A|B], C, D, E) :-
	A=unit(F, G, H, I),
	(   memberchk(F, D)
	->  E=[C, A|B]
	;   E=[A|J],
	    dependency_insert(B, C, D, J)
	).
build_units(A, B, C, D) :-
	build_retrieval_units(A, 1, E, C, F, D, G),
	build_guard_units(B, E, F, G).
build_retrieval_units([], A, A, B, B, C, C).
build_retrieval_units([A|B], C, D, E, F, G, H) :-
	term_variables(A, I),
	update_unit_dictionary(I, C, E, J, [], K),
	G=[unit(C, A, movable, K)|L],
	M is C+1,
	build_retrieval_units2(B, M, D, J, F, L, H).
build_retrieval_units2([], A, A, B, B, C, C).
build_retrieval_units2([A|B], C, D, E, F, G, H) :-
	term_variables(A, I),
	update_unit_dictionary(I, C, E, J, [], K),
	G=[unit(C, A, fixed, K)|L],
	M is C+1,
	build_retrieval_units(B, M, D, J, F, L, H).
initialize_unit_dictionary(A, B) :-
	term_variables(A, C),
	pair_all_with(C, 0, B).
update_unit_dictionary([], A, B, B, C, C).
update_unit_dictionary([A|B], C, D, E, F, G) :-
	(   lookup_eq(D, A, H)
	->  (   (   H==C
		;   memberchk(H, F)
		)
	    ->  I=F
	    ;   I=[H|F]
	    ),
	    J=D
	;   J=[A-C|D],
	    I=F
	),
	update_unit_dictionary(B, C, J, E, I, G).
build_guard_units(A, B, C, D) :-
	(   A=[E]
	->  D=[unit(B, E, fixed, [])]
	;   A=[E|F]
	->  term_variables(E, G),
	    update_unit_dictionary2(G, B, C, H, [], I),
	    D=[unit(B, E, movable, I)|J],
	    K is B+1,
	    build_guard_units(F, K, H, J)
	).
update_unit_dictionary2([], A, B, B, C, C).
update_unit_dictionary2([A|B], C, D, E, F, G) :-
	(   lookup_eq(D, A, H)
	->  (   (   H==C
		;   memberchk(H, F)
		)
	    ->  I=F
	    ;   I=[H|F]
	    ),
	    J=[A-C|D]
	;   J=[A-C|D],
	    I=F
	),
	update_unit_dictionary2(B, C, J, E, I, G).
unique_analyse_optimise(A, B) :-
	(   chr_pp_flag(unique_analyse_optimise, on)
	->  unique_analyse_optimise_main(A, 1, [], B)
	;   B=A
	).
unique_analyse_optimise_main([], A, B, []).
unique_analyse_optimise_main([A|B], C, D, [E|F]) :-
	(   discover_unique_pattern(A, C, G)
	->  H=[G|D]
	;   H=D
	),
	A=pragma(I, J, K, L, M),
	I=rule(N, O, P, Q),
	J=ids(R, S),
	apply_unique_patterns_to_constraints(N, R, H, T),
	apply_unique_patterns_to_constraints(O, S, H, U),
	globalize_unique_pragmas(T, M),
	globalize_unique_pragmas(U, M),
	append_lists([T, U, K], V),
	E=pragma(I, J, V, L, M),
	W is C+1,
	unique_analyse_optimise_main(B, W, H, F).
globalize_unique_pragmas([], A).
globalize_unique_pragmas([unique(A, B)|C], D) :-
	pragma_unique(D, A, B),
	globalize_unique_pragmas(C, D).
apply_unique_patterns_to_constraints([], A, B, []).
apply_unique_patterns_to_constraints([A|B], [C|D], E, F) :-
	(   member(G, E),
	    apply_unique_pattern(A, C, G, H)
	->  F=[H|I]
	;   F=I
	),
	apply_unique_patterns_to_constraints(B, D, E, I).
apply_unique_pattern(A, B, C, D) :-
	C=unique(E, F),
	subsumes(A, E, G),
	(   setof(H, I^J^K^ (member(I, F), lookup_eq(G, I, J), term_variables(J, K), member(H, K)), L)
	->  true
	;   L=[]
	),
	D=unique(B, L).
subsumes(A, B, C) :-
	empty_assoc(D),
	subsumes_aux(A, B, D, E),
	assoc_to_list(E, F),
	build_unifier(F, C).
subsumes_aux(A, B, C, D) :-
	(   compound(B),
	    functor(B, E, F)
	->  compound(A),
	    functor(A, E, F),
	    subsumes_aux(F, A, B, C, D)
	;   A==B
	->  D=C
	;   var(B),
	    get_assoc(A, C, G)
	->  G==B,
	    D=C
	;   var(B),
	    put_assoc(A, C, B, D)
	).
subsumes_aux(0, A, B, C, C) :- !.
subsumes_aux(A, B, C, D, E) :-
	arg(A, B, F),
	arg(A, C, G),
	subsumes_aux(F, G, D, H),
	I is A-1,
	subsumes_aux(I, B, C, H, E).
build_unifier([], []).
build_unifier([A-B|C], [B-A|D]) :-
	build_unifier(C, D).
discover_unique_pattern(A, B, C) :-
	A=pragma(D, E, F, G, B),
	D=rule(H, I, J, K),
	(   H=[L],
	    I=[M]
	->  true
	;   H=[L, M],
	    I==[]
	->  true
	),
	check_unique_constraints(L, M, J, B, N),
	term_variables(L, O),
	select_pragma_unique_variables(N, O, P),
	Q=unique(L, P),
	copy_term(Q, C),
	(   prolog_flag(verbose, R),
	    R==yes
	->  format('Found unique pattern ~w in rule ~d~@\n', [C, B, (G=yes(S)->write([58, 32]), write(S);true)])
	;   true
	).
select_pragma_unique_variables([], A, []).
select_pragma_unique_variables([A-B|C], D, E) :-
	(   A==B
	->  E=[A|F]
	;   once((
		(   \+memberchk_eq(A, D)
		;   \+memberchk_eq(B, D)
		)
		)),
	    E=F
	),
	select_pragma_unique_variables(C, D, F).
check_unique_constraints(A, B, C, D, E) :-
	\+any_passive_head(D),
	variable_replacement(A-B, B-A, E),
	copy_with_variable_replacement(C, F, E),
	negate_b(C, G),
	once(entails_b(G, F)).
check_unnecessary_active(A, B, C) :-
	(   chr_pp_flag(check_unnecessary_active, full)
	->  check_unnecessary_active_main(A, B, C)
	;   chr_pp_flag(check_unnecessary_active, simplification),
	    C=rule(D, [], E, F)
	->  check_unnecessary_active_main(A, B, C)
	;   fail
	).
check_unnecessary_active_main(A, B, C) :-
	member(D, B),
	variable_replacement(D, A, E),
	copy_with_variable_replacement(C, F, E),
	identical_rules(C, F), !.
set_semantics_rule(A) :-
	(   chr_pp_flag(set_semantics_rule, on)
	->  set_semantics_rule_main(A)
	;   fail
	).
set_semantics_rule_main(A) :-
	A=pragma(B, C, D, E, F),
	B=rule([G], [H], true, I),
	C=ids([J], [K]),
	once(member(unique(J, L), D)),
	once(member(unique(K, M), D)),
	L==M,
	\+is_passive(F, J).
identical_rules(rule(A, B, C, D), rule(E, F, G, H)) :-
	C==G,
	identical_bodies(D, H),
	permutation(A, I),
	I==E,
	permutation(B, J),
	J==F.
identical_bodies(A, B) :-
	(   A= (C=D),
	    B= (E=F)
	->  (   C==E,
		D==F
	    ;   C==F,
		E==D
	    ), !
	;   A==B
	).
copy_with_variable_replacement(A, B, C) :-
	(   var(A)
	->  (   lookup_eq(C, A, B)
	    ->  true
	    ;   A=B
	    )
	;   functor(A, D, E),
	    functor(B, D, E),
	    A=..[F|G],
	    B=..[H|I],
	    copy_with_variable_replacement_l(G, I, C)
	).
copy_with_variable_replacement_l([], [], A).
copy_with_variable_replacement_l([A|B], [C|D], E) :-
	copy_with_variable_replacement(A, C, E),
	copy_with_variable_replacement_l(B, D, E).
variable_replacement(A, B, C) :-
	variable_replacement(A, B, [], C).
variable_replacement(A, B, C, D) :-
	(   var(A)
	->  var(B),
	    (   lookup_eq(C, A, E)
	    ->  E==B,
		D=C
	    ;   D=[A-B|C]
	    )
	;   A=..[F|G],
	    nonvar(B),
	    B=..[F|H],
	    variable_replacement_l(G, H, C, D)
	).
variable_replacement_l([], [], A, A).
variable_replacement_l([A|B], [C|D], E, F) :-
	variable_replacement(A, C, E, G),
	variable_replacement_l(B, D, G, F).
simplification_code(A, B, C, D, E/F, G, H, I) :-
	D=pragma(J, K, L, M, N),
	head_info(A, F, O, P, Q, R),
	build_head(E, F, G, Q, S),
	head_arg_matches(R, [], T, U),
	(   B==[]
	->  V=[],
	    W=U,
	    X=[]
	;   rest_heads_retrieval_and_matching(B, C, L, A, X, V, U, W)
	),
	guard_body_copies2(J, W, Y, Z),
	guard_via_reschedule(X, Y, S-T, A1),
	gen_uncond_susps_detachments(V, B, B1),
	gen_cond_susp_detachment(G, P, E/F, C1),
	(   chr_pp_flag(debugable, on)
	->  J=rule(D1, E1, F1, G1),
	    my_term_copy(F1-G1, W, H1, I1-J1),
	    K1='chr debug_event'(try([P|L1], [], I1, J1)),
	    M1='chr debug_event'(apply([P|L1], [], I1, J1))
	;   K1=true,
	    M1=true
	),
	N1= (S:-T, A1, K1, !, M1, B1, C1, Z),
	H=[N1|I].
head_arg_matches(A, B, C, D) :-
	head_arg_matches_(A, B, E, D),
	list2conj(E, C).
head_arg_matches_([], A, [], A).
head_arg_matches_([A-B|C], D, E, F) :-
	(   var(A)
	->  (   lookup_eq(D, A, G)
	    ->  E=[B==G|H],
		I=D
	    ;   I=[A-B|D],
		E=H
	    ),
	    J=C
	;   atomic(A)
	->  E=[B==A|H],
	    D=I,
	    J=C
	;   A=..[K|L],
	    functor(A, M, N),
	    functor(O, M, N),
	    O=..[P|Q],
	    E=[nonvar(B), B=O|H],
	    pairup(L, Q, R),
	    append(R, C, J),
	    I=D
	),
	head_arg_matches_(J, I, H, F).
rest_heads_retrieval_and_matching(A, B, C, D, E, F, G, H) :-
	rest_heads_retrieval_and_matching(A, B, C, D, E, F, G, H, [], [], []).
rest_heads_retrieval_and_matching(A, B, C, D, E, F, G, H, I, J, K) :-
	(   A=[L|M]
	->  rest_heads_retrieval_and_matching_n(A, B, C, I, J, D, E, F, G, H, K)
	;   E=[],
	    F=[],
	    G=H
	).
rest_heads_retrieval_and_matching_n([], A, B, C, D, E, [], [], F, F, G) :-
	instantiate_pattern_goals(G).
rest_heads_retrieval_and_matching_n([A|B], [C|D], E, F, G, H, [I, J|K], [L|M], N, O, P) :-
	functor(A, Q, R),
	get_store_type(Q/R, S),
	(   S==default
	->  passive_head_via(A, [H|F], P, N, I, T, U),
	    get_max_constraint_index(V),
	    (   V==1
	    ->  W=T
	    ;   get_constraint_index(Q/R, X),
		make_attr(V, Y, Z, T),
		nth(X, Z, W)
	    )
	;   lookup_passive_head(S, A, [H|F], N, I, W),
	    U=P
	),
	head_info(A, R, A1, B1, C1, D1),
	head_arg_matches(D1, N, E1, F1),
	G1=..[suspension, H1, I1, J1, K1, L1, M1|A1],
	different_from_other_susps(A, L, F, G, N1),
	create_get_mutable(active, I1, O1),
	P1= ('chr sbag_member'(L, W), L=G1, O1, N1, E1),
	(   member(unique(C, Q1), E),
	    check_unique_keys(Q1, N)
	->  J= (P1->true)
	;   J=P1
	),
	rest_heads_retrieval_and_matching_n(B, D, E, [A|F], [L|G], H, K, M, F1, O, U).
instantiate_pattern_goals([]).
instantiate_pattern_goals([A-attr(B, C, D)|E]) :-
	get_max_constraint_index(F),
	(   F==1
	->  D=true
	;   make_attr(F, G, H, B),
	    or_list(C, I), !,
	    D= (G/\I=:=I)
	),
	instantiate_pattern_goals(E).
check_unique_keys([], A).
check_unique_keys([A|B], C) :-
	lookup_eq(C, A, D),
	check_unique_keys(B, C).
different_from_other_susps(A, B, C, D, E) :-
	(   bagof(F, G^ (nth(G, C, H), \+A\=H, nth(G, D, I), F= (B\==I)), J)
	->  list2conj(J, E)
	;   E=true
	).
passive_head_via(A, B, C, D, E, F, G) :-
	functor(A, H, I),
	get_constraint_index(H/I, J),
	common_variables(A, B, K),
	translate(K, D, L),
	or_pattern(J, M),
	(   permutation(L, N),
	    lookup_eq(C, N, attr(F, O, P))
	->  member(M, O), !,
	    G=C,
	    E=true
	;   E= (Q, R),
	    gen_get_mod_constraints(L, Q, F),
	    G=[L-attr(F, [M|S], R)|C]
	).
common_variables(A, B, C) :-
	term_variables(A, D),
	term_variables(B, E),
	intersect_eq(D, E, C).
gen_get_mod_constraints(A, B, C) :-
	get_target_module(D),
	(   A==[]
	->  B= ('chr global_term_ref_1'(E), get_attr(E, D, F), F=C)
	;   (   A=[G]
	    ->  H='chr via_1'(G, I)
	    ;   A=[G, J]
	    ->  H='chr via_2'(G, J, I)
	    ;   H='chr via'(A, I)
	    ),
	    B= (H, get_attr(I, D, F), F=C)
	).
guard_body_copies(A, B, C, D) :-
	guard_body_copies2(A, B, E, D),
	list2conj(E, C).
guard_body_copies2(A, B, C, D) :-
	A=rule(E, F, G, H),
	conj2list(G, I),
	split_off_simple_guard(I, B, J, K),
	my_term_copy(J-K, B, L, M-N),
	append(M, [O], C),
	term_variables(K, P),
	term_variables(N, Q),
	(   chr_pp_flag(guard_locks, on),
	    bagof('chr lock'(R)-'chr unlock'(R), S^ (member(S, P), lookup_eq(B, S, R), memberchk_eq(R, Q)), T)
	->  once(pairup(U, V, T))
	;   U=[],
	    V=[]
	),
	list2conj(U, W),
	list2conj(V, X),
	list2conj(N, Y),
	O= (W, Y, X),
	my_term_copy(H, L, D).
split_off_simple_guard([], A, [], []).
split_off_simple_guard([A|B], C, D, E) :-
	(   simple_guard(A, C)
	->  D=[A|F],
	    split_off_simple_guard(B, C, F, E)
	;   D=[],
	    E=[A|B]
	).
simple_guard(A, B) :-
	binds_b(A, C),
	\+((
	    member(D, C),
	    lookup_eq(B, D, E)
	    )).
my_term_copy(A, B, C) :-
	my_term_copy(A, B, D, C).
my_term_copy(A, B, C, D) :-
	(   var(A)
	->  (   lookup_eq(B, A, D)
	    ->  C=B
	    ;   C=[A-D|B]
	    )
	;   functor(A, E, F),
	    functor(D, E, F),
	    A=..[G|H],
	    D=..[I|J],
	    my_term_copy_list(H, B, C, J)
	).
my_term_copy_list([], A, A, []).
my_term_copy_list([A|B], C, D, [E|F]) :-
	my_term_copy(A, C, G, E),
	my_term_copy_list(B, G, D, F).
gen_cond_susp_detachment(A, B, C, D) :-
	(   is_attached(C)
	->  (   A==[0],
		\+may_trigger(C)
	    ->  D=true
	    ;   gen_uncond_susp_detachment(B, C, E),
		D= (var(B)->true;E)
	    )
	;   D=true
	).
gen_uncond_susp_detachment(A, B, C) :-
	(   is_attached(B)
	->  (   may_trigger(B)
	    ->  make_name(detach_, B, D),
		E=..[D, F, A]
	    ;   E=true
	    ),
	    (   chr_pp_flag(debugable, on)
	    ->  G='chr debug_event'(remove(A))
	    ;   G=true
	    ),
	    generate_delete_constraint_call(B, A, H),
	    C= (G, remove_constraint_internal(A, F, I), (I==yes->H, E;true))
	;   C=true
	).
gen_uncond_susps_detachments([], [], true).
gen_uncond_susps_detachments([A|B], [C|D], (E, F)) :-
	functor(C, G, H),
	gen_uncond_susp_detachment(A, G/H, E),
	gen_uncond_susps_detachments(B, D, F).
simpagation_head1_code(A, B, C, D, E/F, G, H, I) :-
	D=pragma(J, ids(K, L), M, N, O),
	J=rule(P, Q, R, S),
	head_info(A, F, T, U, V, W),
	head_arg_matches(W, [], X, Y),
	build_head(E, F, G, V, Z),
	append(B, Q, A1),
	append(C, L, B1),
	reorder_heads(O, A, A1, B1, C1, D1),
	rest_heads_retrieval_and_matching(C1, D1, M, A, E1, F1, Y, G1),
	split_by_ids(D1, F1, C, H1, I1),
	guard_body_copies2(J, G1, J1, K1),
	guard_via_reschedule(E1, J1, Z-X, L1),
	gen_uncond_susps_detachments(H1, B, M1),
	gen_cond_susp_detachment(G, U, E/F, N1),
	(   chr_pp_flag(debugable, on)
	->  my_term_copy(R-S, G1, O1, P1-Q1),
	    R1='chr debug_event'(try([U|H1], I1, P1, Q1)),
	    S1='chr debug_event'(apply([U|H1], I1, P1, Q1))
	;   R1=true,
	    S1=true
	),
	T1= (Z:-X, L1, R1, !, S1, M1, N1, K1),
	H=[T1|I].
split_by_ids([], [], A, [], []).
split_by_ids([A|B], [C|D], E, F, G) :-
	(   memberchk_eq(A, E)
	->  F=[C|H],
	    G=I
	;   F=H,
	    G=[C|I]
	),
	split_by_ids(B, D, E, H, I).
simpagation_head2_code(A, B, C, D, E, F, G, H) :-
	D=pragma(I, ids(J, K), L, M, N),
	I=rule(O, P, Q, R),
	reorder_heads(N, A, O, J, [S|T], [U|V]),
	simpagation_head2_prelude(A, S, [B, O, Q, R], E, F, G, W),
	extend_id(F, X),
	simpagation_head2_worker(A, S, U, T, V, B, C, D, E, X, W, H).
simpagation_head2_prelude(A, B, C, D/E, F, G, H) :-
	head_info(A, E, I, J, K, L),
	build_head(D, E, F, K, M),
	head_arg_matches(L, [], N, O),
	lookup_passive_head(B, [A], O, P, Q),
	gen_allocation(F, I, J, D/E, K, R),
	extend_id(F, S),
	extra_active_delegate_variables(A, C, O, T),
	append([Q|K], T, U),
	build_head(D, E, S, U, V),
	W= (M:-N, P, !, R, V),
	G=[W|H].
extra_active_delegate_variables(A, B, C, D) :-
	A=..[E|F],
	delegate_variables(A, B, C, F, D).
passive_delegate_variables(A, B, C, D, E) :-
	term_variables(B, F),
	delegate_variables(A, C, D, F, E).
delegate_variables(A, B, C, D, E) :-
	term_variables(A, F),
	term_variables(B, G),
	intersect_eq(F, G, H),
	list_difference_eq(H, D, I),
	translate(I, C, E).
simpagation_head2_worker(A, B, C, D, E, F, G, H, I, J, K, L) :-
	H=pragma(M, N, O, P, Q),
	M=rule(R, S, T, U),
	simpagation_head2_worker_end(A, [B, D, F, T, U], I, J, K, V),
	simpagation_head2_worker_body(A, B, C, D, E, F, G, H, I, J, V, L).
simpagation_head2_worker_body(A, B, C, D, E, F, G, H, I/J, K, L, M) :-
	gen_var(N),
	gen_var(O),
	head_info(A, J, P, Q, R, S),
	head_arg_matches(S, [], T, U),
	H=pragma(V, W, X, Y, Z),
	V=rule(A1, B1, C1, D1),
	extra_active_delegate_variables(A, [B, D, F, C1, D1], U, E1),
	append([[N|O]|R], E1, F1),
	build_head(I, J, K, F1, G1),
	functor(B, H1, I1),
	head_info(B, I1, J1, K1, L1, M1),
	head_arg_matches(M1, U, N1, O1),
	P1=..[suspension, Q1, R1, S1, T1, U1, V1|J1],
	create_get_mutable(active, R1, W1),
	X1= (N=P1, W1),
	(   (   D\==[]
	    ;   F\==[]
	    )
	->  append(D, F, Y1),
	    append(E, G, Z1),
	    reorder_heads(Z, B-A, Y1, Z1, A2, B2),
	    rest_heads_retrieval_and_matching(A2, B2, X, [B, A], C2, D2, O1, E2, [B], [N], []),
	    split_by_ids(B2, D2, E, F2, G2)
	;   C2=[],
	    F2=[],
	    G2=[],
	    E2=O1
	),
	gen_uncond_susps_detachments([N|F2], [B|D], H2),
	append([O|R], E1, I2),
	build_head(I, J, K, I2, J2),
	append([[]|R], E1, K2),
	build_head(I, J, K, K2, L2),
	guard_body_copies2(V, E2, M2, N2),
	guard_via_reschedule(C2, M2, v(G1, X1, N1), O2),
	(   N2\==true
	->  gen_uncond_attach_goal(I/J, Q, P2, Q2),
	    gen_state_cond_call(Q, J, J2, Q2, R2),
	    gen_state_cond_call(Q, J, L2, Q2, S2)
	;   P2=true,
	    R2=J2,
	    S2=L2
	),
	(   chr_pp_flag(debugable, on)
	->  my_term_copy(C1-D1, E2, T2, U2-V2),
	    W2='chr debug_event'(try([N|F2], [Q|G2], U2, V2)),
	    X2='chr debug_event'(apply([N|F2], [Q|G2], U2, V2))
	;   W2=true,
	    X2=true
	),
	(   member(unique(C, Y2), X),
	    check_unique_keys(Y2, U)
	->  Z2= (G1:-X1, N1-> (O2, W2->X2, H2, P2, N2, S2;L2);J2)
	;   Z2= (G1:-X1, N1, O2, W2->X2, H2, P2, N2, R2;J2)
	),
	L=[Z2|M].
gen_state_cond_call(A, B, C, D, E) :-
	length(F, B),
	G=..[suspension, H, I, J, K, L, M|F],
	create_get_mutable(active, I, N),
	create_get_mutable(D, K, O),
	E= (A=G, N, O->'chr update_mutable'(inactive, I), C;true).
simpagation_head2_worker_end(A, B, C/D, E, F, G) :-
	head_info(A, D, H, I, J, K),
	head_arg_matches(K, [], L, M),
	extra_active_delegate_variables(A, B, M, N),
	append([[]|J], N, O),
	build_head(C, D, E, O, P),
	next_id(E, Q),
	build_head(C, D, Q, J, R),
	S= (P:-R),
	F=[S|G].
propagation_code(A, B, C, D, E, F, G, H, I) :-
	(   B==[]
	->  propagation_single_headed(A, C, D, F, G, H, I)
	;   propagation_multi_headed(A, B, C, D, E, F, G, H, I)
	).
propagation_single_headed(A, B, C, D/E, F, G, H) :-
	head_info(A, E, I, J, K, L),
	build_head(D, E, F, K, M),
	inc_id(F, N),
	build_head(D, E, N, K, O),
	P=O,
	head_arg_matches(L, [], Q, R),
	guard_body_copies(B, R, S, T),
	gen_allocation(F, I, J, D/E, K, U),
	gen_uncond_attach_goal(D/E, J, V, W),
	gen_state_cond_call(J, E, P, W, X),
	(   chr_pp_flag(debugable, on)
	->  B=rule(Y, Z, A1, B1),
	    my_term_copy(A1-B1, R, C1, D1-E1),
	    F1='chr debug_event'(try([], [J], D1, E1)),
	    G1='chr debug_event'(apply([], [J], D1, E1))
	;   F1=true,
	    G1=true
	),
	H1= (M:-Q, U, 'chr novel_production'(J, C), S, F1, !, G1, 'chr extend_history'(J, C), V, T, X),
	G=[H1|H].
propagation_multi_headed(A, B, C, D, E, F, G, H, I) :-
	B=[J|K],
	propagation_prelude(A, B, C, F, G, H, L),
	extend_id(G, M),
	propagation_nested_code(K, [J, A], C, D, E, F, M, L, I).
propagation_prelude(A, [B|C], D, E/F, G, H, I) :-
	head_info(A, F, J, K, L, M),
	build_head(E, F, G, L, N),
	head_arg_matches(M, [], O, P),
	D=rule(Q, R, S, T),
	extra_active_delegate_variables(A, [B, C, S, T], P, U),
	lookup_passive_head(B, [A], P, V, W),
	gen_allocation(G, J, K, E/F, L, X),
	extend_id(G, Y),
	append([W|L], U, Z),
	build_head(E, F, Y, Z, A1),
	B1=A1,
	C1= (N:-O, V, !, X, B1),
	H=[C1|I].
propagation_nested_code([], [A|B], C, D, E, F, G, H, I) :-
	propagation_end([A|B], [], C, F, G, H, J),
	propagation_body(A, B, C, D, E, F, G, J, I).
propagation_nested_code([A|B], C, D, E, F, G, H, I, J) :-
	propagation_end(C, [A|B], D, G, H, I, K),
	propagation_accumulator([A|B], C, D, G, H, K, L),
	inc_id(H, M),
	propagation_nested_code(B, [A|C], D, E, F, G, M, L, J).
propagation_body(A, B, C, D, E, F/G, H, I, J) :-
	C=rule(K, L, M, N),
	get_prop_inner_loop_vars(B, [A, M, N], O, P, Q, R),
	gen_var(S),
	gen_var(T),
	functor(A, U, V),
	gen_vars(V, W),
	X=..[suspension, Y, Z, A1, B1, C1, D1|W],
	create_get_mutable(active, Z, E1),
	F1= (S=X, E1),
	G1=[[S|T]|O],
	build_head(F, G, H, G1, H1),
	I1=[T|O],
	build_head(F, G, H, I1, J1),
	K1=J1,
	A=..[L1|M1],
	pairup(M1, W, N1),
	head_arg_matches(N1, P, O1, P1),
	different_from_other_susps(A, S, B, R, Q1),
	guard_body_copies(C, P1, R1, S1),
	gen_uncond_attach_goal(F/G, Q, T1, U1),
	gen_state_cond_call(Q, G, K1, U1, V1),
	history_susps(E, [S|R], Q, [], W1),
	bagof('chr novel_production'(X1, Y1), (member(X1, W1), Y1=Z1), A2),
	list2conj(A2, B2),
	C2=..[t, D|W1],
	(   chr_pp_flag(debugable, on)
	->  C=rule(D2, E2, M, N),
	    my_term_copy(M-N, P1, F2, G2-H2),
	    I2='chr debug_event'(try([], [Q, S|R], G2, H2)),
	    J2='chr debug_event'(apply([], [Q, S|R], G2, H2))
	;   I2=true,
	    J2=true
	),
	K2= (H1:-F1, Q1, O1, Z1=C2, B2, R1, I2->J2, 'chr extend_history'(Q, Z1), T1, S1, V1;K1),
	I=[K2|J].
history_susps(A, B, C, D, E) :-
	(   A==0
	->  reverse(B, F),
	    append(F, [C|D], E)
	;   B=[G|H],
	    I is A-1,
	    history_susps(I, H, C, [G|D], E)
	).
get_prop_inner_loop_vars([A], B, C, D, E, []) :- !,
	functor(A, F, G),
	head_info(A, G, H, E, I, J),
	head_arg_matches(J, [], K, D),
	extra_active_delegate_variables(A, B, D, L),
	append(I, L, C).
get_prop_inner_loop_vars([A|B], C, D, E, F, [G|H]) :-
	get_prop_inner_loop_vars(B, [A|C], I, J, F, H),
	functor(A, K, L),
	gen_var(M),
	head_info(A, L, N, G, O, P),
	head_arg_matches(P, J, Q, E),
	passive_delegate_variables(A, B, C, E, R),
	append(R, [G, M|I], D).
propagation_end([A|B], C, D, E/F, G, H, I) :-
	D=rule(J, K, L, M),
	gen_var_susp_list_for(B, [A, C, L, M], N, O, P, Q),
	R=[[]|O],
	build_head(E, F, G, R, S),
	(   G=[0|T]
	->  next_id(G, U),
	    V=P
	;   dec_id(G, U),
	    V=[Q|P]
	),
	build_head(E, F, U, V, W),
	X=W,
	Y= (S:-X),
	H=[Y|I].
gen_var_susp_list_for([A], B, C, D, E, F) :- !,
	functor(A, G, H),
	head_info(A, H, I, F, E, J),
	head_arg_matches(J, [], K, C),
	extra_active_delegate_variables(A, B, C, L),
	append(E, L, D).
gen_var_susp_list_for([A|B], C, D, E, F, G) :-
	gen_var_susp_list_for(B, [A|C], H, F, I, J),
	functor(A, K, L),
	gen_var(G),
	head_info(A, L, M, N, O, P),
	head_arg_matches(P, H, Q, D),
	passive_delegate_variables(A, B, C, D, R),
	append(R, [N, G|F], E).
propagation_accumulator([A|B], [C|D], E, F/G, H, I, J) :-
	E=rule(K, L, M, N),
	pre_vars_and_susps(D, [C, A, B, M, N], O, P, Q),
	gen_var(R),
	functor(C, S, T),
	gen_vars(T, U),
	head_info(C, T, U, V, W, X),
	head_arg_matches(X, P, Y, Z),
	A1=..[suspension, B1, C1, D1, E1, F1, G1|U],
	different_from_other_susps(C, V, D, Q, H1),
	create_get_mutable(active, C1, I1),
	J1= (V=A1, I1, H1, Y),
	lookup_passive_head(A, [C|D], Z, K1, L1),
	inc_id(H, M1),
	N1=[[V|R]|O],
	build_head(F, G, H, N1, O1),
	passive_delegate_variables(C, D, [A, B, M, N], Z, P1),
	append([L1|P1], [V, R|O], Q1),
	build_head(F, G, M1, Q1, R1),
	S1=[R|O],
	build_head(F, G, H, S1, T1),
	U1= (O1:-J1, K1->R1;T1),
	I=[U1|J].
pre_vars_and_susps([A], B, C, D, []) :- !,
	functor(A, E, F),
	head_info(A, F, G, H, I, J),
	head_arg_matches(J, [], K, D),
	extra_active_delegate_variables(A, B, D, L),
	append(I, L, C).
pre_vars_and_susps([A|B], C, D, E, [F|G]) :-
	pre_vars_and_susps(B, [A|C], H, I, G),
	functor(A, J, K),
	gen_var(L),
	head_info(A, K, M, F, N, O),
	head_arg_matches(O, I, P, E),
	passive_delegate_variables(A, B, C, E, Q),
	append(Q, [F, L|H], D).
reorder_heads(A, B, C, D, E, F) :-
	(   chr_pp_flag(reorder_heads, on)
	->  reorder_heads_main(A, B, C, D, E, F)
	;   E=C,
	    F=D
	).
reorder_heads_main(A, B, C, D, E, F) :-
	term_variables(B, G),
	H=entry([], [], G, C, D, A),
	a_star(H, I^ (chr_translate:final_data(I)), J^K^L^ (chr_translate:expand_data(J, K, L)), M),
	M=entry(N, O, P, Q, R, S),
	reverse(N, E),
	reverse(O, F).
final_data(A) :-
	A=entry(B, C, D, E, [], F).
expand_data(A, B, C) :-
	A=entry(D, E, F, G, H, I),
	term_variables(A, J),
	B=entry([K|D], [L|E], M, N, O, I),
	select2(K, L, G, H, N, O),
	order_score(K, L, F, N, I, C),
	term_variables([K|F], M).
order_score(A, B, C, D, E, F) :-
	functor(A, G, H),
	get_store_type(G/H, I),
	order_score(I, A, B, C, D, E, F).
order_score(default, A, B, C, D, E, F) :-
	term_variables(A, G),
	term_variables(D, H),
	order_score_vars(G, C, D, 0, F).
order_score(multi_hash(A), B, C, D, E, F, G) :-
	order_score_indexes(A, B, D, 0, G).
order_score(global_ground, A, B, C, D, E, F) :-
	functor(A, G, H),
	(   get_pragma_unique(E, B, I),
	    I==[]
	->  F=1
	;   H==0
	->  F=10
	;   H>0
	->  F=100
	).
order_score(multi_store(A), B, C, D, E, F, G) :-
	find_with_var_identity(H, t(B, D, E), (member(I, A), chr_translate:order_score(I, B, C, D, E, F, H)), J),
	min_list(J, G).
order_score_indexes([], A, B, C, C) :-
	C>0.
order_score_indexes([A|B], C, D, E, F) :-
	multi_hash_key_args(A, C, G),
	(   forall(H, G, hprolog:memberchk_eq(H, D))
	->  I is E+10
	;   I=E
	),
	order_score_indexes(B, C, D, I, F).
order_score_vars([], A, B, C, D) :-
	(   C==0
	->  D=0
	;   D=C
	).
order_score_vars([A|B], C, D, E, F) :-
	(   memberchk_eq(A, C)
	->  G is E+10
	;   memberchk_eq(A, D)
	->  G is E+100
	;   G=E
	),
	order_score_vars(B, C, D, G, F).
create_get_mutable(A, B, C) :-
	C= (B=mutable(A)).
gen_var(A).
gen_vars(A, B) :-
	length(B, A).
head_info(A, B, C, D, E, F) :-
	vars_susp(B, C, D, E),
	A=..[G|H],
	pairup(H, C, F).
inc_id([A|B], [C|B]) :-
	C is A+1.
dec_id([A|B], [C|B]) :-
	C is A-1.
extend_id(A, [0|A]).
next_id([A, B|C], [D|C]) :-
	D is B+1.
build_head(A, B, C, D, E) :-
	buildName(A, B, C, F),
	E=..[F|D].
buildName(A, B, C, D) :-
	atom_concat(A, /, E),
	atom_concat(E, B, F),
	buildName_(C, F, D).
buildName_([], A, A).
buildName_([A|B], C, D) :-
	buildName_(B, C, E),
	atom_concat(E, '__', F),
	atom_concat(F, A, D).
vars_susp(A, B, C, D) :-
	length(B, A),
	append(B, [C], D).
make_attr(A, B, C, D) :-
	length(C, A),
	D=..[v, B|C].
or_pattern(A, B) :-
	C is A-1,
	B is 1<<C.
and_pattern(A, B) :-
	C is A-1,
	D is 1<<C,
	B is-1* (D+1).
conj2list(A, B) :-
	conj2list(A, B, []).
conj2list(A, B, C) :-
	A= (D, E), !,
	conj2list(D, B, F),
	conj2list(E, F, C).
conj2list(A, [A|B], B).
list2conj([], true).
list2conj([A], B) :- !,
	B=A.
list2conj([A|B], C) :-
	(   A==true
	->  list2conj(B, C)
	;   C= (A, D),
	    list2conj(B, D)
	).
list2disj([], fail).
list2disj([A], B) :- !,
	B=A.
list2disj([A|B], C) :-
	(   A==fail
	->  list2disj(B, C)
	;   C= (A;D),
	    list2disj(B, D)
	).
atom_concat_list([A], A) :- !.
atom_concat_list([A|B], C) :-
	atom_concat_list(B, D),
	atom_concat(A, D, C).
make_name(A, B/C, D) :-
	atom_concat_list([A, B, /, C], D).
set_elems([], A).
set_elems([A|B], A) :-
	set_elems(B, A).
member2([A|B], [C|D], A-C).
member2([A|B], [C|D], E) :-
	member2(B, D, E).
select2(A, B, [A|C], [B|D], C, D).
select2(A, B, [C|D], [E|F], [C|G], [E|H]) :-
	select2(A, B, D, F, G, H).
pair_all_with([], A, []).
pair_all_with([A|B], C, [A-C|D]) :-
	pair_all_with(B, C, D).
lookup_passive_head(A, B, C, D, E) :-
	functor(A, F, G),
	get_store_type(F/G, H),
	lookup_passive_head(H, A, B, C, D, E).
lookup_passive_head(default, A, B, C, D, E) :-
	passive_head_via(A, B, [], C, D, F, G),
	instantiate_pattern_goals(G),
	get_max_constraint_index(H),
	(   H==1
	->  E=F
	;   functor(A, I, J),
	    get_constraint_index(I/J, K),
	    make_attr(H, L, M, F),
	    nth(K, M, E)
	).
lookup_passive_head(multi_hash(A), B, C, D, E, F) :-
	once((
	    member(G, A),
	    multi_hash_key_args(G, B, H),
	    translate(H, D, I)
	    )),
	(   I=[J]
	->  true
	;   J=..[k|I]
	),
	functor(B, K, L),
	multi_hash_via_lookup_name(K/L, G, M),
	E=..[M, J, F],
	update_store_type(K/L, multi_hash([G])).
lookup_passive_head(global_ground, A, B, C, D, E) :-
	functor(A, F, G),
	global_ground_store_name(F/G, H),
	D=nb_getval(H, E),
	update_store_type(F/G, global_ground).
lookup_passive_head(multi_store(A), B, C, D, E, F) :-
	once((
	    member(G, A),
	    lookup_passive_head(G, B, C, D, E, F)
	    )).
assume_constraint_stores([]).
assume_constraint_stores([A|B]) :-
	(   \+may_trigger(A),
	    is_attached(A),
	    get_store_type(A, default)
	->  get_indexed_arguments(A, C),
	    findall(D, (sublist(D, C), D\==[]), E),
	    assumed_store_type(A, multi_store([multi_hash(E), global_ground]))
	;   true
	),
	assume_constraint_stores(B).
get_indexed_arguments(A, B) :-
	A=C/D,
	get_indexed_arguments(1, D, A, B).
get_indexed_arguments(A, B, C, D) :-
	(   A>B
	->  D=[]
	;   (   is_indexed_argument(C, A)
	    ->  D=[A|E]
	    ;   D=E
	    ),
	    F is A+1,
	    get_indexed_arguments(F, B, C, E)
	).
validate_store_type_assumptions([]).
validate_store_type_assumptions([A|B]) :-
	validate_store_type_assumption(A),
	validate_store_type_assumptions(B).
attr_unify_hook(A, B) :-
	write('ERROR: Unexpected triggering of attr_unify_hook/2 in module '),
	writeln(chr_translate).
remove_constraint_internal(A, B, C) :-
	arg(2, A, D),
	D=mutable(E),
	'chr update_mutable'(removed, D),
	(   compound(E)
	->  B=[],
	    C=no
	;   E==removed
	->  B=[],
	    C=no
	;   C=yes,
	    chr_indexed_variables(A, B)
	).
activate_constraint(A, B, C, D) :-
	arg(2, C, E),
	E=mutable(F),
	'chr update_mutable'(active, E),
	(   nonvar(D)
	->  true
	;   arg(4, C, G),
	    G=mutable(H),
	    D is H+1,
	    'chr update_mutable'(D, G)
	),
	(   compound(F)
	->  term_variables(F, B),
	    'chr none_locked'(B),
	    A=yes
	;   F==removed
	->  chr_indexed_variables(C, B),
	    A=yes
	;   B=[],
	    A=no
	).
allocate_constraint(A, B, C, D) :-
	B=..[suspension, E, F, A, G, H, C|D],
	G=mutable(0),
	'chr empty_history'(I),
	H=mutable(I),
	chr_indexed_variables(B, J),
	F=mutable(passive(J)),
	'chr gen_id'(E).
chr_indexed_variables(A, []).
insert_constraint_internal(yes, A, B, C, D, E) :-
	B=..[suspension, F, G, C, H, I, D|E],
	chr_indexed_variables(B, A),
	'chr none_locked'(A),
	G=mutable(active),
	H=mutable(0),
	I=mutable(J),
	'chr empty_history'(J),
	'chr gen_id'(F).
'$insert_in_store_constraint/2'(A) :-
	arg(8, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:constraint/2-2', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_constraint/2'(A) :-
	arg(8, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:constraint/2-2', C),
	delete_ht(C, B, A),
	true.
'$insert_in_store_constraint_count/1'(A) :-
	nb_getval('$chr_store_global_ground_chr_translate:constraint_count/1', B),
	b_setval('$chr_store_global_ground_chr_translate:constraint_count/1', [A|B]).
'$delete_from_store_constraint_count/1'(A) :-
	nb_getval('$chr_store_global_ground_chr_translate:constraint_count/1', B),
	'chr sbag_del_element'(B, A, C),
	b_setval('$chr_store_global_ground_chr_translate:constraint_count/1', C).
'$insert_in_store_constraint_index/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:constraint_index/2-1', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_constraint_index/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:constraint_index/2-1', C),
	delete_ht(C, B, A),
	true.
'$insert_in_store_max_constraint_index/1'(A) :-
	nb_getval('$chr_store_global_ground_chr_translate:max_constraint_index/1', B),
	b_setval('$chr_store_global_ground_chr_translate:max_constraint_index/1', [A|B]).
'$delete_from_store_max_constraint_index/1'(A) :-
	nb_getval('$chr_store_global_ground_chr_translate:max_constraint_index/1', B),
	'chr sbag_del_element'(B, A, C),
	b_setval('$chr_store_global_ground_chr_translate:max_constraint_index/1', C).
'$insert_in_store_target_module/1'(A) :-
	nb_getval('$chr_store_global_ground_chr_translate:target_module/1', B),
	b_setval('$chr_store_global_ground_chr_translate:target_module/1', [A|B]).
'$delete_from_store_target_module/1'(A) :-
	nb_getval('$chr_store_global_ground_chr_translate:target_module/1', B),
	'chr sbag_del_element'(B, A, C),
	b_setval('$chr_store_global_ground_chr_translate:target_module/1', C).
'$insert_in_store_attached/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:attached/2-1', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_attached/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:attached/2-1', C),
	delete_ht(C, B, A),
	true.
'$insert_in_store_indexed_argument/2'(A) :-
	arg(7, A, B),
	arg(8, A, C),
	nb_getval('$chr_store_multi_hash_chr_translate:indexed_argument/2-12', D),
	insert_ht(D, k(B, C), A),
	true.
'$delete_from_store_indexed_argument/2'(A) :-
	arg(7, A, B),
	arg(8, A, C),
	nb_getval('$chr_store_multi_hash_chr_translate:indexed_argument/2-12', D),
	delete_ht(D, k(B, C), A),
	true.
'$insert_in_store_constraint_mode/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:constraint_mode/2-1', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_constraint_mode/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:constraint_mode/2-1', C),
	delete_ht(C, B, A),
	true.
'$insert_in_store_store_type/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:store_type/2-1', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_store_type/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:store_type/2-1', C),
	delete_ht(C, B, A),
	true.
'$insert_in_store_actual_store_types/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:actual_store_types/2-1', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_actual_store_types/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:actual_store_types/2-1', C),
	delete_ht(C, B, A),
	true.
'$insert_in_store_assumed_store_type/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:assumed_store_type/2-1', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_assumed_store_type/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:assumed_store_type/2-1', C),
	delete_ht(C, B, A),
	true.
'$insert_in_store_rule_count/1'(A) :-
	nb_getval('$chr_store_global_ground_chr_translate:rule_count/1', B),
	b_setval('$chr_store_global_ground_chr_translate:rule_count/1', [A|B]).
'$delete_from_store_rule_count/1'(A) :-
	nb_getval('$chr_store_global_ground_chr_translate:rule_count/1', B),
	'chr sbag_del_element'(B, A, C),
	b_setval('$chr_store_global_ground_chr_translate:rule_count/1', C).
'$insert_in_store_passive/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:passive/2-1', C),
	insert_ht(C, B, A),
	true,
	arg(7, A, D),
	arg(8, A, E),
	nb_getval('$chr_store_multi_hash_chr_translate:passive/2-12', F),
	insert_ht(F, k(D, E), A),
	true.
'$delete_from_store_passive/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:passive/2-1', C),
	delete_ht(C, B, A),
	true,
	arg(7, A, D),
	arg(8, A, E),
	nb_getval('$chr_store_multi_hash_chr_translate:passive/2-12', F),
	delete_ht(F, k(D, E), A),
	true.
'$insert_in_store_pragma_unique/3'(A) :-
	arg(7, A, B),
	arg(8, A, C),
	nb_getval('$chr_store_multi_hash_chr_translate:pragma_unique/3-12', D),
	insert_ht(D, k(B, C), A),
	true.
'$delete_from_store_pragma_unique/3'(A) :-
	arg(7, A, B),
	arg(8, A, C),
	nb_getval('$chr_store_multi_hash_chr_translate:pragma_unique/3-12', D),
	delete_ht(D, k(B, C), A),
	true.
'$insert_in_store_occurrence/4'(A) :-
	arg(9, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-3', C),
	insert_ht(C, B, A),
	true,
	arg(8, A, D),
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-2', E),
	insert_ht(E, D, A),
	true,
	arg(7, A, F),
	arg(8, A, G),
	arg(9, A, H),
	arg(10, A, I),
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-1234', J),
	insert_ht(J, k(F, G, H, I), A),
	true.
'$delete_from_store_occurrence/4'(A) :-
	arg(9, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-3', C),
	delete_ht(C, B, A),
	true,
	arg(8, A, D),
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-2', E),
	delete_ht(E, D, A),
	true,
	arg(7, A, F),
	arg(8, A, G),
	arg(9, A, H),
	arg(10, A, I),
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-1234', J),
	delete_ht(J, k(F, G, H, I), A),
	true.
'$insert_in_store_max_occurrence/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:max_occurrence/2-1', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_max_occurrence/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:max_occurrence/2-1', C),
	delete_ht(C, B, A),
	true.
'$insert_in_store_allocation_occurrence/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-1', C),
	insert_ht(C, B, A),
	true,
	arg(7, A, D),
	arg(8, A, E),
	nb_getval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-12', F),
	insert_ht(F, k(D, E), A),
	true,
	nb_getval('$chr_store_global_ground_chr_translate:allocation_occurrence/2', G),
	b_setval('$chr_store_global_ground_chr_translate:allocation_occurrence/2', [A|G]).
'$delete_from_store_allocation_occurrence/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-1', C),
	delete_ht(C, B, A),
	true,
	arg(7, A, D),
	arg(8, A, E),
	nb_getval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-12', F),
	delete_ht(F, k(D, E), A),
	true,
	nb_getval('$chr_store_global_ground_chr_translate:allocation_occurrence/2', G),
	'chr sbag_del_element'(G, A, H),
	b_setval('$chr_store_global_ground_chr_translate:allocation_occurrence/2', H).
'$insert_in_store_rule/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:rule/2-1', C),
	insert_ht(C, B, A),
	true.
'$delete_from_store_rule/2'(A) :-
	arg(7, A, B),
	nb_getval('$chr_store_multi_hash_chr_translate:rule/2-1', C),
	delete_ht(C, B, A),
	true.
'$enumerate_suspensions'(A) :-
	(   nb_getval('$chr_store_multi_hash_chr_translate:constraint/2-2', B),
	    value_ht(B, A)
	;   nb_getval('$chr_store_global_ground_chr_translate:constraint_count/1', C),
	    'chr sbag_member'(A, C)
	;   nb_getval('$chr_store_multi_hash_chr_translate:constraint_index/2-1', D),
	    value_ht(D, A)
	;   nb_getval('$chr_store_global_ground_chr_translate:max_constraint_index/1', E),
	    'chr sbag_member'(A, E)
	;   nb_getval('$chr_store_global_ground_chr_translate:target_module/1', F),
	    'chr sbag_member'(A, F)
	;   nb_getval('$chr_store_multi_hash_chr_translate:attached/2-1', G),
	    value_ht(G, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:indexed_argument/2-12', H),
	    value_ht(H, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:constraint_mode/2-1', I),
	    value_ht(I, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:store_type/2-1', J),
	    value_ht(J, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:actual_store_types/2-1', K),
	    value_ht(K, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:assumed_store_type/2-1', L),
	    value_ht(L, A)
	;   nb_getval('$chr_store_global_ground_chr_translate:rule_count/1', M),
	    'chr sbag_member'(A, M)
	;   nb_getval('$chr_store_multi_hash_chr_translate:passive/2-1', N),
	    value_ht(N, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:pragma_unique/3-12', O),
	    value_ht(O, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-3', P),
	    value_ht(P, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:max_occurrence/2-1', Q),
	    value_ht(Q, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-1', R),
	    value_ht(R, A)
	;   nb_getval('$chr_store_multi_hash_chr_translate:rule/2-1', S),
	    value_ht(S, A)
	).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:constraint/2-2', A).
'$via1_multi_hash_constraint/2-2'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:constraint/2-2', C),
	lookup_ht(C, A, B).
:-nb_setval('$chr_store_global_ground_chr_translate:constraint_count/1', []).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:constraint_index/2-1', A).
'$via1_multi_hash_constraint_index/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:constraint_index/2-1', C),
	lookup_ht(C, A, B).
:-nb_setval('$chr_store_global_ground_chr_translate:max_constraint_index/1', []).
:-nb_setval('$chr_store_global_ground_chr_translate:target_module/1', []).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:attached/2-1', A).
'$via1_multi_hash_attached/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:attached/2-1', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:indexed_argument/2-12', A).
'$via1_multi_hash_indexed_argument/2-12'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:indexed_argument/2-12', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:constraint_mode/2-1', A).
'$via1_multi_hash_constraint_mode/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:constraint_mode/2-1', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:store_type/2-1', A).
'$via1_multi_hash_store_type/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:store_type/2-1', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:actual_store_types/2-1', A).
'$via1_multi_hash_actual_store_types/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:actual_store_types/2-1', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:assumed_store_type/2-1', A).
'$via1_multi_hash_assumed_store_type/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:assumed_store_type/2-1', C),
	lookup_ht(C, A, B).
:-nb_setval('$chr_store_global_ground_chr_translate:rule_count/1', []).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:passive/2-1', A).
'$via1_multi_hash_passive/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:passive/2-1', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:passive/2-12', A).
'$via1_multi_hash_passive/2-12'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:passive/2-12', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:pragma_unique/3-12', A).
'$via1_multi_hash_pragma_unique/3-12'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:pragma_unique/3-12', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:occurrence/4-3', A).
'$via1_multi_hash_occurrence/4-3'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-3', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:occurrence/4-2', A).
'$via1_multi_hash_occurrence/4-2'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-2', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:occurrence/4-1234', A).
'$via1_multi_hash_occurrence/4-1234'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:occurrence/4-1234', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:max_occurrence/2-1', A).
'$via1_multi_hash_max_occurrence/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:max_occurrence/2-1', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-1', A).
'$via1_multi_hash_allocation_occurrence/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-1', C),
	lookup_ht(C, A, B).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-12', A).
'$via1_multi_hash_allocation_occurrence/2-12'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:allocation_occurrence/2-12', C),
	lookup_ht(C, A, B).
:-nb_setval('$chr_store_global_ground_chr_translate:allocation_occurrence/2', []).
:-new_ht(A), nb_setval('$chr_store_multi_hash_chr_translate:rule/2-1', A).
'$via1_multi_hash_rule/2-1'(A, B) :-
	nb_getval('$chr_store_multi_hash_chr_translate:rule/2-1', C),
	lookup_ht(C, A, B).
constraint(A, B) :-
	'constraint/2__0'(A, B, C).
'constraint/2__0'(A, B, C) :-
	insert_constraint_internal(D, E, C, chr_translate:'constraint/2__0'(A, B, C), constraint(A, B), [A, B]),
	'$insert_in_store_constraint/2'(C).
get_constraint(A, B) :-
	'get_constraint/2__0'(A, B, C).
'get_constraint/2__0'(A, B, C) :-
	'$via1_multi_hash_constraint/2-2'(B, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	M==B, !,
	A=L.
'get_constraint/2__0'(A, B, C) :- !,
	fail.
constraint_count(A) :-
	'constraint_count/1__0'(A, B).
'constraint_count/1__0'(A, B) :-
	insert_constraint_internal(C, D, B, chr_translate:'constraint_count/1__0'(A, B), constraint_count(A), [A]),
	'$insert_in_store_constraint_count/1'(B).
get_constraint_count(A) :-
	'get_constraint_count/1__0'(A, B).
'get_constraint_count/1__0'(A, B) :-
	nb_getval('$chr_store_global_ground_chr_translate:constraint_count/1', C),
	'chr sbag_member'(D, C),
	D=suspension(E, F, G, H, I, J, K),
	F=mutable(active), !,
	A=K.
'get_constraint_count/1__0'(A, B) :- !,
	A=0.
constraint_index(A, B) :-
	'constraint_index/2__0'(A, B, C).
'constraint_index/2__0'(A, B, C) :-
	insert_constraint_internal(D, E, C, chr_translate:'constraint_index/2__0'(A, B, C), constraint_index(A, B), [A, B]),
	'$insert_in_store_constraint_index/2'(C).
get_constraint_index(A, B) :-
	'get_constraint_index/2__0'(A, B, C).
'get_constraint_index/2__0'(A, B, C) :-
	'$via1_multi_hash_constraint_index/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A, !,
	B=M.
'get_constraint_index/2__0'(A, B, C) :- !,
	fail.
max_constraint_index(A) :-
	'max_constraint_index/1__0'(A, B).
'max_constraint_index/1__0'(A, B) :-
	insert_constraint_internal(C, D, B, chr_translate:'max_constraint_index/1__0'(A, B), max_constraint_index(A), [A]),
	'$insert_in_store_max_constraint_index/1'(B).
get_max_constraint_index(A) :-
	'get_max_constraint_index/1__0'(A, B).
'get_max_constraint_index/1__0'(A, B) :-
	nb_getval('$chr_store_global_ground_chr_translate:max_constraint_index/1', C),
	'chr sbag_member'(D, C),
	D=suspension(E, F, G, H, I, J, K),
	F=mutable(active), !,
	A=K.
'get_max_constraint_index/1__0'(A, B) :- !,
	A=0.
target_module(A) :-
	'target_module/1__0'(A, B).
'target_module/1__0'(A, B) :-
	insert_constraint_internal(C, D, B, chr_translate:'target_module/1__0'(A, B), target_module(A), [A]),
	'$insert_in_store_target_module/1'(B).
get_target_module(A) :-
	'get_target_module/1__0'(A, B).
'get_target_module/1__0'(A, B) :-
	nb_getval('$chr_store_global_ground_chr_translate:target_module/1', C),
	'chr sbag_member'(D, C),
	D=suspension(E, F, G, H, I, J, K),
	F=mutable(active), !,
	A=K.
'get_target_module/1__0'(A, B) :- !,
	A=user.
attached(A, B) :-
	'attached/2__0'(A, B, C).
'attached/2__0'(A, B, C) :-
	'$via1_multi_hash_attached/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A,
	M==yes, !.
'attached/2__0'(A, B, C) :-
	B==yes,
	'$via1_multi_hash_attached/2-1'(A, D), !,
	allocate_constraint(chr_translate:'attached/2__0'(A, B, C), C, attached(A, B), [A, B]),
	'attached/2__0__0'(D, A, B, C).
'attached/2__0__0'([], A, B, C) :-
	'attached/2__1'(A, B, C).
'attached/2__0__0'([A|B], C, D, E) :-
	(   A=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==C
	->  remove_constraint_internal(A, N, O),
	    (   O==yes
	    ->  '$delete_from_store_attached/2'(A)
	    ;   true
	    ),
	    'attached/2__0__0'(B, C, D, E)
	;   'attached/2__0__0'(B, C, D, E)
	).
'attached/2__0'(A, B, C) :-
	allocate_constraint(chr_translate:'attached/2__0'(A, B, C), C, attached(A, B), [A, B]),
	'attached/2__1'(A, B, C).
'attached/2__1'(A, B, C) :-
	'$via1_multi_hash_attached/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A,
	M==no, !,
	(   var(C)
	->  true
	;   remove_constraint_internal(C, N, O),
	    (   O==yes
	    ->  '$delete_from_store_attached/2'(C)
	    ;   true
	    )
	).
'attached/2__1'(A, B, C) :-
	B==no,
	'$via1_multi_hash_attached/2-1'(A, D), !,
	'attached/2__1__0'(D, A, B, C).
'attached/2__1__0'([], A, B, C) :-
	'attached/2__2'(A, B, C).
'attached/2__1__0'([A|B], C, D, E) :-
	(   A=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==C
	->  remove_constraint_internal(A, N, O),
	    (   O==yes
	    ->  '$delete_from_store_attached/2'(A)
	    ;   true
	    ),
	    'attached/2__1__0'(B, C, D, E)
	;   'attached/2__1__0'(B, C, D, E)
	).
'attached/2__1'(A, B, C) :-
	'attached/2__2'(A, B, C).
'attached/2__2'(A, B, C) :-
	B==maybe,
	'$via1_multi_hash_attached/2-1'(A, D),
	(   'chr sbag_member'(E, D),
	    E=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==A,
	    M==maybe
	->  true
	), !,
	(   var(C)
	->  true
	;   remove_constraint_internal(C, N, O),
	    (   O==yes
	    ->  '$delete_from_store_attached/2'(C)
	    ;   true
	    )
	).
'attached/2__2'(A, B, C) :-
	activate_constraint(D, E, C, F),
	(   D==yes
	->  '$insert_in_store_attached/2'(C)
	;   true
	).
is_attached(A) :-
	'is_attached/1__0'(A, B).
'is_attached/1__0'(A, B) :-
	'$via1_multi_hash_attached/2-1'(A, C),
	'chr sbag_member'(D, C),
	D=suspension(E, F, G, H, I, J, K, L),
	F=mutable(active),
	K==A, !,
	L\==no.
'is_attached/1__0'(A, B) :- !.
indexed_argument(A, B) :-
	'indexed_argument/2__0'(A, B, C).
'indexed_argument/2__0'(A, B, C) :-
	'$via1_multi_hash_indexed_argument/2-12'(k(A, B), D),
	(   'chr sbag_member'(E, D),
	    E=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==A,
	    M==B
	->  true
	), !.
'indexed_argument/2__0'(A, B, C) :-
	insert_constraint_internal(D, E, C, chr_translate:'indexed_argument/2__0'(A, B, C), indexed_argument(A, B), [A, B]),
	'$insert_in_store_indexed_argument/2'(C).
is_indexed_argument(A, B) :-
	'is_indexed_argument/2__0'(A, B, C).
'is_indexed_argument/2__0'(A, B, C) :-
	'$via1_multi_hash_indexed_argument/2-12'(k(A, B), D),
	(   'chr sbag_member'(E, D),
	    E=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==A,
	    M==B
	->  true
	), !.
'is_indexed_argument/2__0'(A, B, C) :- !,
	fail.
constraint_mode(A, B) :-
	'constraint_mode/2__0'(A, B, C).
'constraint_mode/2__0'(A, B, C) :-
	insert_constraint_internal(D, E, C, chr_translate:'constraint_mode/2__0'(A, B, C), constraint_mode(A, B), [A, B]),
	'$insert_in_store_constraint_mode/2'(C).
get_constraint_mode(A, B) :-
	'get_constraint_mode/2__0'(A, B, C).
'get_constraint_mode/2__0'(A, B, C) :-
	'$via1_multi_hash_constraint_mode/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A, !,
	B=M.
'get_constraint_mode/2__0'(A, B, C) :- !,
	A=D/E,
	length(B, E),
	set_elems(B, ?).
may_trigger(A) :-
	'may_trigger/1__0'(A, B).
'may_trigger/1__0'(A, B) :- !,
	is_attached(A),
	get_constraint_mode(A, C),
	has_nonground_indexed_argument(A, 1, C).
has_nonground_indexed_argument(A, B, C) :-
	'has_nonground_indexed_argument/3__0'(A, B, C, D).
'has_nonground_indexed_argument/3__0'(A, B, C, D) :-
	nonvar(C),
	C=[E|F], !,
	(   is_indexed_argument(A, B),
	    E\== +
	->  true
	;   G is B+1,
	    has_nonground_indexed_argument(A, G, F)
	).
'has_nonground_indexed_argument/3__0'(A, B, C, D) :- !,
	fail.
store_type(A, B) :-
	'store_type/2__0'(A, B, C).
'store_type/2__0'(A, B, C) :-
	nonvar(B),
	B=atom_hash(D), !,
	store_type(A, multi_hash([D])).
'store_type/2__0'(A, B, C) :-
	insert_constraint_internal(D, E, C, chr_translate:'store_type/2__0'(A, B, C), store_type(A, B), [A, B]),
	'$insert_in_store_store_type/2'(C).
get_store_type(A, B) :-
	'get_store_type/2__0'(A, B, C).
'get_store_type/2__0'(A, B, C) :-
	'$via1_multi_hash_store_type/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A, !,
	B=M.
'get_store_type/2__0'(A, B, C) :-
	'$via1_multi_hash_assumed_store_type/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A, !,
	B=M.
'get_store_type/2__0'(A, B, C) :- !,
	B=default.
update_store_type(A, B) :-
	'update_store_type/2__0'(A, B, C).
'update_store_type/2__0'(A, B, C) :-
	'$via1_multi_hash_actual_store_types/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A,
	'chr lock'(B),
	member(B, M),
	'chr unlock'(B), !.
'update_store_type/2__0'(A, B, C) :-
	'$via1_multi_hash_actual_store_types/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A, !,
	remove_constraint_internal(E, N, O),
	(   O==yes
	->  '$delete_from_store_actual_store_types/2'(E)
	;   true
	),
	actual_store_types(A, [B|M]).
'update_store_type/2__0'(A, B, C) :- !,
	actual_store_types(A, [B]).
actual_store_types(A, B) :-
	'actual_store_types/2__0'(A, B, C).
'actual_store_types/2__0'(A, B, C) :-
	insert_constraint_internal(D, E, C, chr_translate:'actual_store_types/2__0'(A, B, C), actual_store_types(A, B), [A, B]),
	'$insert_in_store_actual_store_types/2'(C).
assumed_store_type(A, B) :-
	'assumed_store_type/2__0'(A, B, C).
'assumed_store_type/2__0'(A, B, C) :-
	insert_constraint_internal(D, E, C, chr_translate:'assumed_store_type/2__0'(A, B, C), assumed_store_type(A, B), [A, B]),
	'$insert_in_store_assumed_store_type/2'(C).
validate_store_type_assumption(A) :-
	'validate_store_type_assumption/1__0'(A, B).
'validate_store_type_assumption/1__0'(A, B) :-
	'$via1_multi_hash_assumed_store_type/2-1'(A, C),
	'$via1_multi_hash_actual_store_types/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A,
	'chr sbag_member'(N, C),
	N=suspension(O, P, Q, R, S, T, U, V),
	P=mutable(active),
	U==A, !,
	remove_constraint_internal(E, W, X),
	(   X==yes
	->  '$delete_from_store_actual_store_types/2'(E)
	;   true
	),
	remove_constraint_internal(N, Y, Z),
	(   Z==yes
	->  '$delete_from_store_assumed_store_type/2'(N)
	;   true
	),
	store_type(A, multi_store(M)).
'validate_store_type_assumption/1__0'(A, B) :-
	'$via1_multi_hash_store_type/2-1'(A, C),
	'$via1_multi_hash_actual_store_types/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A,
	'chr sbag_member'(N, C),
	N=suspension(O, P, Q, R, S, T, U, V),
	P=mutable(active),
	U==A, !,
	remove_constraint_internal(E, W, X),
	(   X==yes
	->  '$delete_from_store_actual_store_types/2'(E)
	;   true
	),
	remove_constraint_internal(N, Y, Z),
	(   Z==yes
	->  '$delete_from_store_store_type/2'(N)
	;   true
	),
	store_type(A, multi_store(M)).
'validate_store_type_assumption/1__0'(A, B) :- !.
rule_count(A) :-
	'rule_count/1__0'(A, B).
'rule_count/1__0'(A, B) :-
	insert_constraint_internal(C, D, B, chr_translate:'rule_count/1__0'(A, B), rule_count(A), [A]),
	'$insert_in_store_rule_count/1'(B).
inc_rule_count(A) :-
	'inc_rule_count/1__0'(A, B).
'inc_rule_count/1__0'(A, B) :-
	nb_getval('$chr_store_global_ground_chr_translate:rule_count/1', C),
	'chr sbag_member'(D, C),
	D=suspension(E, F, G, H, I, J, K),
	F=mutable(active), !,
	remove_constraint_internal(D, L, M),
	(   M==yes
	->  '$delete_from_store_rule_count/1'(D)
	;   true
	),
	A is K+1,
	rule_count(A).
'inc_rule_count/1__0'(A, B) :- !,
	A=1,
	rule_count(A).
get_rule_count(A) :-
	'get_rule_count/1__0'(A, B).
'get_rule_count/1__0'(A, B) :-
	nb_getval('$chr_store_global_ground_chr_translate:rule_count/1', C),
	'chr sbag_member'(D, C),
	D=suspension(E, F, G, H, I, J, K),
	F=mutable(active), !,
	A=K.
'get_rule_count/1__0'(A, B) :- !,
	A=0.
passive(A, B) :-
	'passive/2__0'(A, B, C).
'passive/2__0'(A, B, C) :-
	nb_getval('$chr_store_global_ground_chr_translate:allocation_occurrence/2', D), !,
	allocate_constraint(chr_translate:'passive/2__0'(A, B, C), C, passive(A, B), [A, B]),
	'passive/2__0__0'(D, A, B, C).
'passive/2__0__0'([], A, B, C) :-
	'passive/2__1'(A, B, C).
'passive/2__0__0'([A|B], C, D, E) :-
	(   A=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    '$via1_multi_hash_occurrence/4-1234'(k(L, M, C, D), N),
	    'chr sbag_member'(O, N),
	    O=suspension(P, Q, R, S, T, U, V, W, X, Y),
	    Q=mutable(active),
	    V==L,
	    W==M,
	    X==C,
	    Y==D
	->  remove_constraint_internal(A, Z, A1),
	    (   A1==yes
	    ->  '$delete_from_store_allocation_occurrence/2'(A)
	    ;   true
	    ),
	    activate_constraint(B1, C1, E, D1),
	    (   B1==yes
	    ->  '$insert_in_store_passive/2'(E)
	    ;   true
	    ),
	    E1 is M+1,
	    allocation_occurrence(L, E1),
	    (   E=suspension(F1, G1, H1, I1, J1, K1, L1, M1),
		G1=mutable(active),
		I1=mutable(D1)
	    ->  'chr update_mutable'(inactive, G1),
		'passive/2__0__0'(B, C, D, E)
	    ;   true
	    )
	;   'passive/2__0__0'(B, C, D, E)
	).
'passive/2__0'(A, B, C) :-
	allocate_constraint(chr_translate:'passive/2__0'(A, B, C), C, passive(A, B), [A, B]),
	'passive/2__1'(A, B, C).
'passive/2__1'(A, B, C) :-
	activate_constraint(D, E, C, F),
	(   D==yes
	->  '$insert_in_store_passive/2'(C)
	;   true
	).
is_passive(A, B) :-
	'is_passive/2__0'(A, B, C).
'is_passive/2__0'(A, B, C) :-
	'$via1_multi_hash_passive/2-12'(k(A, B), D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A,
	M==B, !.
'is_passive/2__0'(A, B, C) :- !,
	fail.
any_passive_head(A) :-
	'any_passive_head/1__0'(A, B).
'any_passive_head/1__0'(A, B) :-
	'$via1_multi_hash_passive/2-1'(A, C),
	'chr sbag_member'(D, C),
	D=suspension(E, F, G, H, I, J, K, L),
	F=mutable(active),
	K==A, !.
'any_passive_head/1__0'(A, B) :- !,
	fail.
pragma_unique(A, B, C) :-
	'pragma_unique/3__0'(A, B, C, D).
'pragma_unique/3__0'(A, B, C, D) :-
	insert_constraint_internal(E, F, D, chr_translate:'pragma_unique/3__0'(A, B, C, D), pragma_unique(A, B, C), [A, B, C]),
	'$insert_in_store_pragma_unique/3'(D).
get_pragma_unique(A, B, C) :-
	'get_pragma_unique/3__0'(A, B, C, D).
'get_pragma_unique/3__0'(A, B, C, D) :-
	'$via1_multi_hash_pragma_unique/3-12'(k(A, B), E),
	'chr sbag_member'(F, E),
	F=suspension(G, H, I, J, K, L, M, N, O),
	H=mutable(active),
	M==A,
	N==B, !,
	C=O.
'get_pragma_unique/3__0'(A, B, C, D) :- !.
occurrence(A, B, C, D) :-
	'occurrence/4__0'(A, B, C, D, E).
'occurrence/4__0'(A, B, C, D, E) :-
	allocate_constraint(chr_translate:'occurrence/4__0'(A, B, C, D, E), E, occurrence(A, B, C, D), [A, B, C, D]),
	'chr novel_production'(E, 46), !,
	'chr extend_history'(E, 46),
	activate_constraint(F, G, E, H),
	(   F==yes
	->  '$insert_in_store_occurrence/4'(E)
	;   true
	),
	max_occurrence(A, B),
	(   E=suspension(I, J, K, L, M, N, O, P, Q, R),
	    J=mutable(active),
	    L=mutable(H)
	->  'chr update_mutable'(inactive, J),
	    'occurrence/4__1'(A, B, C, D, E)
	;   true
	).
'occurrence/4__0'(A, B, C, D, E) :-
	allocate_constraint(chr_translate:'occurrence/4__0'(A, B, C, D, E), E, occurrence(A, B, C, D), [A, B, C, D]),
	'occurrence/4__1'(A, B, C, D, E).
'occurrence/4__1'(A, B, C, D, E) :-
	'$via1_multi_hash_allocation_occurrence/2-12'(k(A, B), F), !,
	'occurrence/4__1__0'(F, A, B, C, D, E).
'occurrence/4__1__0'([], A, B, C, D, E) :-
	'occurrence/4__2'(A, B, C, D, E).
'occurrence/4__1__0'([A|B], C, D, E, F, G) :-
	(   A=suspension(H, I, J, K, L, M, N, O),
	    I=mutable(active),
	    N==C,
	    O==D,
	    '$via1_multi_hash_rule/2-1'(E, P),
	    'chr sbag_member'(Q, P),
	    Q=suspension(R, S, T, U, V, W, X, Y),
	    S=mutable(active),
	    X==E,
	    'chr lock'(Y),
	    Y=pragma(Z, ids(A1, B1), C1, D1, E1),
	    member(F, F1),
	    'chr unlock'(Y)
	->  remove_constraint_internal(A, G1, H1),
	    (   H1==yes
	    ->  '$delete_from_store_allocation_occurrence/2'(A)
	    ;   true
	    ),
	    activate_constraint(I1, J1, G, K1),
	    (   I1==yes
	    ->  '$insert_in_store_occurrence/4'(G)
	    ;   true
	    ),
	    L1 is D+1,
	    allocation_occurrence(C, L1),
	    (   G=suspension(M1, N1, O1, P1, Q1, R1, S1, T1, U1, V1),
		N1=mutable(active),
		P1=mutable(K1)
	    ->  'chr update_mutable'(inactive, N1),
		'occurrence/4__1__0'(B, C, D, E, F, G)
	    ;   true
	    )
	;   'occurrence/4__1__0'(B, C, D, E, F, G)
	).
'occurrence/4__1'(A, B, C, D, E) :-
	'occurrence/4__2'(A, B, C, D, E).
'occurrence/4__2'(A, B, C, D, E) :-
	'$via1_multi_hash_allocation_occurrence/2-12'(k(A, B), F), !,
	'occurrence/4__2__0'(F, A, B, C, D, E).
'occurrence/4__2__0'([], A, B, C, D, E) :-
	'occurrence/4__3'(A, B, C, D, E).
'occurrence/4__2__0'([A|B], C, D, E, F, G) :-
	(   A=suspension(H, I, J, K, L, M, N, O),
	    I=mutable(active),
	    N==C,
	    O==D,
	    '$via1_multi_hash_rule/2-1'(E, P),
	    'chr sbag_member'(Q, P),
	    Q=suspension(R, S, T, U, V, W, X, Y),
	    S=mutable(active),
	    X==E,
	    'chr lock'(Y),
	    Y=pragma(rule(Z, A1, B1, true), C1, D1, E1, F1),
	    'chr unlock'(Y)
	->  remove_constraint_internal(A, G1, H1),
	    (   H1==yes
	    ->  '$delete_from_store_allocation_occurrence/2'(A)
	    ;   true
	    ),
	    activate_constraint(I1, J1, G, K1),
	    (   I1==yes
	    ->  '$insert_in_store_occurrence/4'(G)
	    ;   true
	    ),
	    L1 is D+1,
	    allocation_occurrence(C, L1),
	    (   G=suspension(M1, N1, O1, P1, Q1, R1, S1, T1, U1, V1),
		N1=mutable(active),
		P1=mutable(K1)
	    ->  'chr update_mutable'(inactive, N1),
		'occurrence/4__2__0'(B, C, D, E, F, G)
	    ;   true
	    )
	;   'occurrence/4__2__0'(B, C, D, E, F, G)
	).
'occurrence/4__2'(A, B, C, D, E) :-
	'occurrence/4__3'(A, B, C, D, E).
'occurrence/4__3'(A, B, C, D, E) :-
	'$via1_multi_hash_allocation_occurrence/2-12'(k(A, B), F), !,
	'occurrence/4__3__0'(F, A, B, C, D, E).
'occurrence/4__3__0'([], A, B, C, D, E) :-
	'occurrence/4__4'(A, B, C, D, E).
'occurrence/4__3__0'([A|B], C, D, E, F, G) :-
	(   A=suspension(H, I, J, K, L, M, N, O),
	    I=mutable(active),
	    N==C,
	    O==D,
	    '$via1_multi_hash_passive/2-12'(k(E, F), P),
	    'chr sbag_member'(Q, P),
	    Q=suspension(R, S, T, U, V, W, X, Y),
	    S=mutable(active),
	    X==E,
	    Y==F
	->  remove_constraint_internal(A, Z, A1),
	    (   A1==yes
	    ->  '$delete_from_store_allocation_occurrence/2'(A)
	    ;   true
	    ),
	    activate_constraint(B1, C1, G, D1),
	    (   B1==yes
	    ->  '$insert_in_store_occurrence/4'(G)
	    ;   true
	    ),
	    E1 is D+1,
	    allocation_occurrence(C, E1),
	    (   G=suspension(F1, G1, H1, I1, J1, K1, L1, M1, N1, O1),
		G1=mutable(active),
		I1=mutable(D1)
	    ->  'chr update_mutable'(inactive, G1),
		'occurrence/4__3__0'(B, C, D, E, F, G)
	    ;   true
	    )
	;   'occurrence/4__3__0'(B, C, D, E, F, G)
	).
'occurrence/4__3'(A, B, C, D, E) :-
	'occurrence/4__4'(A, B, C, D, E).
'occurrence/4__4'(A, B, C, D, E) :-
	activate_constraint(F, G, E, H),
	(   F==yes
	->  '$insert_in_store_occurrence/4'(E)
	;   true
	).
get_occurrence(A, B, C, D) :-
	'get_occurrence/4__0'(A, B, C, D, E).
'get_occurrence/4__0'(A, B, C, D, E) :-
	'$via1_multi_hash_occurrence/4-2'(B, F),
	'chr sbag_member'(G, F),
	G=suspension(H, I, J, K, L, M, N, O, P, Q),
	I=mutable(active),
	N==A,
	O==B, !,
	P=C,
	Q=D.
'get_occurrence/4__0'(A, B, C, D, E) :- !,
	fail.
max_occurrence(A, B) :-
	'max_occurrence/2__0'(A, B, C).
'max_occurrence/2__0'(A, B, C) :-
	'$via1_multi_hash_max_occurrence/2-1'(A, D),
	(   'chr sbag_member'(E, D),
	    E=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==A
	->  true
	),
	M>=B, !.
'max_occurrence/2__0'(A, B, C) :-
	'$via1_multi_hash_max_occurrence/2-1'(A, D), !,
	allocate_constraint(chr_translate:'max_occurrence/2__0'(A, B, C), C, max_occurrence(A, B), [A, B]),
	'max_occurrence/2__0__0'(D, A, B, C).
'max_occurrence/2__0__0'([], A, B, C) :-
	'max_occurrence/2__1'(A, B, C).
'max_occurrence/2__0__0'([A|B], C, D, E) :-
	(   A=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==C
	->  (   D>=M
	    ->  remove_constraint_internal(A, N, O),
		(   O==yes
		->  '$delete_from_store_max_occurrence/2'(A)
		;   true
		),
		'max_occurrence/2__0__0'([], C, D, E)
	    ;   'max_occurrence/2__0__0'([], C, D, E)
	    )
	;   'max_occurrence/2__0__0'(B, C, D, E)
	).
'max_occurrence/2__0'(A, B, C) :-
	allocate_constraint(chr_translate:'max_occurrence/2__0'(A, B, C), C, max_occurrence(A, B), [A, B]),
	'max_occurrence/2__1'(A, B, C).
'max_occurrence/2__1'(A, B, C) :-
	activate_constraint(D, E, C, F),
	(   D==yes
	->  '$insert_in_store_max_occurrence/2'(C)
	;   true
	).
get_max_occurrence(A, B) :-
	'get_max_occurrence/2__0'(A, B, C).
'get_max_occurrence/2__0'(A, B, C) :-
	'$via1_multi_hash_max_occurrence/2-1'(A, D),
	(   'chr sbag_member'(E, D),
	    E=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    L==A
	->  true
	), !,
	B=M.
'get_max_occurrence/2__0'(A, B, C) :- !,
	B=0.
allocation_occurrence(A, B) :-
	'allocation_occurrence/2__0'(A, B, C).
'allocation_occurrence/2__0'(A, B, C) :-
	'$via1_multi_hash_occurrence/4-2'(B, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M, N, O),
	G=mutable(active),
	L==A,
	M==B,
	'$via1_multi_hash_rule/2-1'(N, P),
	'chr sbag_member'(Q, P),
	Q=suspension(R, S, T, U, V, W, X, Y),
	S=mutable(active),
	X==N,
	'chr lock'(Y),
	Y=pragma(Z, ids(A1, B1), C1, D1, E1),
	member(O, F1),
	'chr unlock'(Y), !,
	G1 is B+1,
	allocation_occurrence(A, G1).
'allocation_occurrence/2__0'(A, B, C) :-
	'$via1_multi_hash_occurrence/4-2'(B, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M, N, O),
	G=mutable(active),
	L==A,
	M==B,
	'$via1_multi_hash_rule/2-1'(N, P),
	'chr sbag_member'(Q, P),
	Q=suspension(R, S, T, U, V, W, X, Y),
	S=mutable(active),
	X==N,
	'chr lock'(Y),
	Y=pragma(rule(Z, A1, B1, true), C1, D1, E1, F1),
	'chr unlock'(Y), !,
	G1 is B+1,
	allocation_occurrence(A, G1).
'allocation_occurrence/2__0'(A, B, C) :-
	'$via1_multi_hash_occurrence/4-2'(B, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M, N, O),
	G=mutable(active),
	L==A,
	M==B,
	'$via1_multi_hash_passive/2-12'(k(N, O), P),
	'chr sbag_member'(Q, P),
	Q=suspension(R, S, T, U, V, W, X, Y),
	S=mutable(active),
	X==N,
	Y==O, !,
	Z is B+1,
	allocation_occurrence(A, Z).
'allocation_occurrence/2__0'(A, B, C) :-
	insert_constraint_internal(D, E, C, chr_translate:'allocation_occurrence/2__0'(A, B, C), allocation_occurrence(A, B), [A, B]),
	'$insert_in_store_allocation_occurrence/2'(C).
get_allocation_occurrence(A, B) :-
	'get_allocation_occurrence/2__0'(A, B, C).
'get_allocation_occurrence/2__0'(A, B, C) :-
	'$via1_multi_hash_allocation_occurrence/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A, !,
	B=M.
'get_allocation_occurrence/2__0'(A, B, C) :- !,
	fail.
rule(A, B) :-
	'rule/2__0'(A, B, C).
'rule/2__0'(A, B, C) :-
	nb_getval('$chr_store_global_ground_chr_translate:allocation_occurrence/2', D), !,
	allocate_constraint(chr_translate:'rule/2__0'(A, B, C), C, rule(A, B), [A, B]),
	'rule/2__0__0'(D, A, B, C).
'rule/2__0__0'([], A, B, C) :-
	'rule/2__1'(A, B, C).
'rule/2__0__0'([A|B], C, D, E) :-
	(   A=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    '$via1_multi_hash_occurrence/4-3'(C, N),
	    'chr sbag_member'(O, N),
	    O=suspension(P, Q, R, S, T, U, V, W, X, Y),
	    Q=mutable(active),
	    V==L,
	    W==M,
	    X==C,
	    'chr lock'(D),
	    D=pragma(Z, ids(A1, B1), C1, D1, E1),
	    member(Y, F1),
	    'chr unlock'(D)
	->  remove_constraint_internal(A, G1, H1),
	    (   H1==yes
	    ->  '$delete_from_store_allocation_occurrence/2'(A)
	    ;   true
	    ),
	    activate_constraint(I1, J1, E, K1),
	    (   I1==yes
	    ->  '$insert_in_store_rule/2'(E)
	    ;   true
	    ),
	    L1 is M+1,
	    allocation_occurrence(L, L1),
	    (   E=suspension(M1, N1, O1, P1, Q1, R1, S1, T1),
		N1=mutable(active),
		P1=mutable(K1)
	    ->  'chr update_mutable'(inactive, N1),
		'rule/2__0__0'(B, C, D, E)
	    ;   true
	    )
	;   'rule/2__0__0'(B, C, D, E)
	).
'rule/2__0'(A, B, C) :-
	allocate_constraint(chr_translate:'rule/2__0'(A, B, C), C, rule(A, B), [A, B]),
	'rule/2__1'(A, B, C).
'rule/2__1'(A, B, C) :-
	nb_getval('$chr_store_global_ground_chr_translate:allocation_occurrence/2', D), !,
	'rule/2__1__0'(D, A, B, C).
'rule/2__1__0'([], A, B, C) :-
	'rule/2__2'(A, B, C).
'rule/2__1__0'([A|B], C, D, E) :-
	(   A=suspension(F, G, H, I, J, K, L, M),
	    G=mutable(active),
	    '$via1_multi_hash_occurrence/4-3'(C, N),
	    'chr sbag_member'(O, N),
	    O=suspension(P, Q, R, S, T, U, V, W, X, Y),
	    Q=mutable(active),
	    V==L,
	    W==M,
	    X==C,
	    'chr lock'(D),
	    D=pragma(rule(Z, A1, B1, true), C1, D1, E1, F1),
	    'chr unlock'(D)
	->  remove_constraint_internal(A, G1, H1),
	    (   H1==yes
	    ->  '$delete_from_store_allocation_occurrence/2'(A)
	    ;   true
	    ),
	    activate_constraint(I1, J1, E, K1),
	    (   I1==yes
	    ->  '$insert_in_store_rule/2'(E)
	    ;   true
	    ),
	    L1 is M+1,
	    allocation_occurrence(L, L1),
	    (   E=suspension(M1, N1, O1, P1, Q1, R1, S1, T1),
		N1=mutable(active),
		P1=mutable(K1)
	    ->  'chr update_mutable'(inactive, N1),
		'rule/2__1__0'(B, C, D, E)
	    ;   true
	    )
	;   'rule/2__1__0'(B, C, D, E)
	).
'rule/2__1'(A, B, C) :-
	'rule/2__2'(A, B, C).
'rule/2__2'(A, B, C) :-
	activate_constraint(D, E, C, F),
	(   D==yes
	->  '$insert_in_store_rule/2'(C)
	;   true
	).
get_rule(A, B) :-
	'get_rule/2__0'(A, B, C).
'get_rule/2__0'(A, B, C) :-
	'$via1_multi_hash_rule/2-1'(A, D),
	'chr sbag_member'(E, D),
	E=suspension(F, G, H, I, J, K, L, M),
	G=mutable(active),
	L==A, !,
	B=M.
'get_rule/2__0'(A, B, C) :- !,
	fail.
